<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="favicon.ico?v=10">
<link rel="icon" type="image/png" sizes="32x32" href="images/rocket_favicon_32.png?v=10">
<link rel="icon" type="image/png" sizes="64x64" href="images/rocket_favicon_64.png?v=10">
<link rel="apple-touch-icon" sizes="180x180" href="images/rocket_favicon_180.png?v=10">
<meta name="theme-color" content="#0b1020">
<title>Alvessa: An Agentic Evidence‑Grounded Research Assistant for Genomics</title>

<style>
  :root{ --bg:#0b1020; --fg:#e6e8ef; --card:#121832; --muted:#aab4d6; --line:#1e2a52; --pill-bg:#1a2347; --pill-line:#2a3a72; --accent:#2a3a72; --input:#0e1430; --shadow:0 6px 24px rgba(0,0,0,.2); --radius:16px; --r-sm:10px; --mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; --sans:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{ margin:0; background:var(--bg); color:var(--fg); font-family:var(--sans); overflow-anchor:none; }
  a{ color:inherit; text-decoration:underline; text-underline-offset:2px; }
  .wrap{ max-width:1100px; margin:24px auto; padding:0 16px; }
  .grid{ display:grid; gap:16px; grid-template-columns:1fr 1fr; }
  .full{ grid-column:1 / -1; }

  /* Cards */
  .card{ background:var(--card); border:1px solid var(--line); border-radius:var(--radius); padding:16px; box-shadow:var(--shadow); }
  .title{ font-size:20px; font-weight:700; margin:0 0 8px; }
  .muted{ color:var(--muted); font-size:12px; }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .mono{ font-family:var(--mono); }
  .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:var(--pill-bg); border:1px solid var(--pill-line); margin:2px 6px 2px 0; font-size:12px; }

  /* Inputs */
  button{ cursor:pointer; background:#1b2450; color:var(--fg); border:1px solid var(--pill-line); border-radius:var(--r-sm); padding:8px 12px; }
  button.ghost{ background:transparent; }
  input[type="text"],select{ background:var(--input); color:var(--fg); border:1px solid var(--pill-line); border-radius:var(--r-sm); padding:10px; }
  input[type="text"]{ width:100%; }

  /* Brand */
  .brand-header{ grid-column:1/-1; display:flex; align-items:center; justify-content:center; gap:12px; padding:8px 0; }
  .logo-brand{ height:44px; }
  .brand-title{ margin:0; font-weight:800; text-align:center; font-size:clamp(24px,3.2vw,38px); letter-spacing:.2px; }

  /* Hero */
  #hero{ min-height:50vh; display:grid; place-items:center; }
  #hero .card{ width:100%; max-width:720px; text-align:center; }
  #grid, #toolbar{ display:none; }

  /* Spinner + status */
  .spinner{ width:16px; height:16px; border:2px solid var(--accent); border-top-color:transparent; border-radius:50%; animation:spin 1s linear infinite; display:inline-block; vertical-align:middle; margin-right:6px; }
  .spinner.big{ width:28px; height:28px; border-width:3px; margin-right:8px; }
  @keyframes spin{ to{ transform:rotate(360deg); } }
  .statusline{ font-family:var(--mono); font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:72ch; }

  /* Variant Summary */
  .vs-toolbar{ display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-bottom:6px; }
  .vs-scroll{ overflow:auto; max-height:420px; }


  /* Protein viewer iframe */
.prot-frame { width: 100%; height: 720px; border: 1px solid #1e2a52; border-radius: 12px; background: #0e1430; }
body.light .prot-frame { background: #ffffff; border-color: #cbd5e1; }

  

  /* Citations */
  .cite{ cursor:help; user-select:none; text-decoration:underline dotted; }
  .cite-tip{ position:fixed; z-index:9999; max-width:420px; background:var(--input); color:var(--fg); border:1px solid var(--pill-line); border-radius:10px; padding:8px 10px; font-size:12px; line-height:1.4; box-shadow:0 8px 24px rgba(0,0,0,.4); pointer-events:none; opacity:0; transform:translateY(4px); transition:opacity .08s ease, transform .08s ease; }
  .cite-tip.show{ opacity:1; transform:translateY(0); }
  .refs-list{ margin:8px 0 0; padding-left:18px; }
  .refs-list li{ margin:6px 0; }
  .refs-list .muted{ margin-top:2px; display:block; }

  /* Light mode */
  body.light{ background:#fff; color:#0b1020; }
  body.light .card{ background:#fff; border-color:#d8dce6; color:#0b1020; box-shadow:0 6px 24px rgba(0,0,0,.06); }
  body.light input[type="text"], body.light select{ background:#fff; color:#0b1020; border:1px solid #c8cfe0; }
  body.light button{ background:#f3f5fb; color:#0b1020; border:1px solid #c8cfe0; }
  body.light .muted{ color:#6b7280; }
  body.light .pill{ background:#eef1f7; border:1px solid #d6d9e6; color:#0b1020; }
  body.light .vs-table thead th{ background:#f5f7fb; color:#0b1020; }
  body.light .cite-tip{ background:#fff; color:#0b1020; border-color:#e5e7eb; box-shadow:0 10px 30px rgba(0,0,0,.10); }

  /* Markdown-ish spacing */
  .answer p{ margin:.45em 0; }
  .answer h2, .answer h3, .answer h4{ margin:.6em 0 .3em; }
  .answer ul{ margin:.35em 0 .35em 1.2em; }
  .answer li{ margin:.15em 0; }


  /* Utility */
  .hide{ display:none !important; }
  /* Let fixed layout honor column widths */
/* Make the variant table predictable and scrollable */
.vs-scroll{
  overflow-x: auto;        /* explicit horizontal scroll */
  overflow-y: auto;
  max-height: 420px;
}

/* One definitive table rule (avoid duplicates) */
.vs-table{
  width: 100%;
  min-width: 3200px;       /* plenty of room; adjust if needed */
  border-collapse: collapse;
  table-layout: fixed;     /* required for colgroup widths to apply */
}

/* Default: keep tight columns tidy (no bleed into neighbors) */
.vs-table th,
.vs-table td{
  padding: 8px 12px;
  font-size: 13px;
  line-height: 1.45;
  white-space: nowrap;
  overflow: hidden;            /* prevents visual overlap */
  text-overflow: ellipsis;     /* shows … for clipped text */
}

/* Columns that should wrap */
.vs-table th.wrap,
.vs-table td.wrap{
  white-space: normal;
  overflow: visible;           /* allow multi-line content to show */
}

/* Sticky header + hover (unchanged) */
.vs-table thead th{ position: sticky; top: 0; background: var(--card); z-index: 1; }
.vs-table tbody tr:hover{ background: rgba(42,58,114,0.12); }

/* Ref/Alt: header never breaks; cells wrap long alleles */
.vs-table th.seq{ white-space: nowrap; }
.vs-table td.seq{
  white-space: normal;
  word-break: break-word;
  overflow-wrap: anywhere;
  font-family: var(--mono);
}

/* Traits: make the column wide AND force each pill to wrap inside the cell */
.vs-table col.col-traits { width: 1600px; }      /* wide GWAS column */

.vs-table td.traits{ max-width: 1600px; }        /* match col width */
.vs-table td.traits .pill{
  display: inline-block;
  max-width: 100%;            /* <-- key: pill never wider than the cell */
  white-space: normal;        /* allow wrapping within the pill */
  word-break: break-word;
  overflow-wrap: anywhere;
  vertical-align: top;
}
.vs-table col.col-pos { width: 120px; }   /* chrom/positions */
.vs-table col.col-seq { width: 240px; }   /* Ref/Alt */
.vs-table col.col-num { width: 120px; }   /* p-value / AF */



#tsmr .mr-block{ margin-bottom:14px; }
#tsmr .mr-head{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
#tsmr .mr-sum{ margin:6px 0 8px; }
#tsmr .pill.ghost{ background:transparent; }
#tsmr table{ width:100%; border-collapse:collapse; table-layout:fixed; }
#tsmr th,#tsmr td{ border-bottom:1px solid var(--line); padding:6px 8px; text-align:left; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
#tsmr thead th{ position:sticky; top:0; background:var(--card); z-index:1; }
#tsmr .scroll{ overflow:auto; max-height:360px; }




</style>

<body>
<div class="wrap">
  <button id="themeToggle" aria-label="Toggle theme" style="position:fixed;top:12px;right:12px;z-index:999;">Toggle Theme</button>

  <!-- Hero / landing (no auto-demo load) -->
  <div id="hero" role="region" aria-label="Landing">
    <div class="card">
      <div class="title" style="display:flex;align-items:center;justify-content:center;gap:8px;">
        <img src="images/rocket_logo.png" alt="Alvessa logo" style="height:40px;" />
        <span>Alvessa: An Agentic Evidence‑Grounded Research Assistant for Genomics</span>
      </div>
      <p class="muted" style="margin-bottom:12px;">Load a JSON produced by Alvessa or ask a question (if the server endpoint is wired).</p>
      <div class="row" style="justify-content:center; width:100%; gap:8px;">
        <input id="q" type="text" placeholder="Ask a question… e.g., Genes interacting with TP53" aria-label="Question" />
        <button id="runBtn" aria-label="Run query">Run</button>
        <label class="pill" style="cursor:pointer;">
          Load JSON
          <input id="jsonFile" type="file" accept=".json,application/json" style="display:none;">
        </label>
      </div>
      <div class="row" style="justify-content:center;margin-top:8px;">
        <select id="demoSelect">
          <option value="">Load demo… (not auto‑selected)</option>
          <option value="out/20250924-004900_ui/demo.json">TP53 demo</option>
        </select>
        <button id="downloadBtn" class="pill">Download JSON</button>
      </div>
      <div class="muted" style="margin-top:8px;">Tip: nothing loads until you choose a file or click Run.</div>
    </div>
  </div>

  <!-- Toolbar -->
  <div id="toolbar" class="card full">
    <div class="row" style="justify-content:space-between; gap:12px;">
      <div class="row"><div class="muted" style="min-width:160px;">Ask another question</div></div>
      <div class="row" style="flex:1;">
        <input id="q2" type="text" placeholder="Type another question… then press Enter" aria-label="Another question" />
        <button id="runBtn2">Run</button>
        <label class="pill" style="cursor:pointer;">
          Load JSON
          <input id="jsonFile2" type="file" accept=".json,application/json" style="display:none;">
        </label>
      </div>
    </div>
  </div>

  <!-- Main grid -->
  <div id="grid" class="grid">
    <div class="brand-header">
      <img src="images/rocket_logo.png" alt="Alvessa logo" class="logo-brand" />
      <h1 class="brand-title">Alvessa: An Agentic Evidence‑Grounded Research Assistant for Genomics</h1>
    </div>

    <div class="card full">
      <div class="title" id="questionTitle">Question</div>
      <div id="question" style="font-size:18px;"></div>
    </div>

    <div id="answerCard" class="card full" data-section style="display:none;">
      <div class="title">Answer</div>
      <div id="answer" class="answer"></div>
      <ol id="citations" class="refs-list"></ol>
    </div>

    <div id="entitiesCard" class="card full" data-section style="display:none;">
      <div class="title">Detected Entities</div>
      <div id="entities"></div>
    </div>

    <div id="geneSummaryCard" class="card full" data-section style="display:none;">
      <div class="title">Gene Summary</div>
      <div id="geneSummary"></div>
    </div>

    <!-- Variant Summary -->
    <div id="variantSummaryCard" class="card full" data-section style="display:none;">
      <div class="title">Variant Summary</div>
      <div class="vs-toolbar">
        <input id="vsFilter" type="text" placeholder="Filter (gene, rsID, trait, consequence…)" aria-label="Filter variants" style="flex:1;max-width:360px;">
        <button id="vsCsvBtn" class="ghost">Download CSV</button>
      </div>
      <div id="variantSummary"></div>
    </div>

    <!-- Protein Visualization -->
<div id="protCard" class="card full" data-section style="display:none;">
  <div class="title">Protein Structure</div>
  <div id="protMount"></div>
</div>

<!-- Two-sample MR -->
<div id="tsmrCard" class="card full" data-section style="display:none;">
  <div class="title">Two-sample Mendelian Randomization</div>
  <div id="tsmr"></div>
</div>


    <div id="evidenceCard" class="card full" data-section style="display:none;">
      <div class="title">Evidence</div>
      <div id="evidence"></div>
    </div>

    <!-- Minimal debug (toggle-able) -->
    <div id="rawCard" class="card full" data-section style="display:none;">
      <div class="title">Raw State (debug)</div>
      <pre id="raw" class="mono" style="max-height:340px;overflow:auto;"></pre>
    </div>
  </div>
</div>

<script>
/********************
 * Utilities
 ********************/
const show = id => { const el=document.getElementById(id); if (!el) return; el.style.display = el.classList.contains('grid') ? 'grid' : 'block'; };
const hide  = id => { const el=document.getElementById(id); if (el) el.style.display='none'; };
const setText = (id, text) => { const el=document.getElementById(id); if (el) el.textContent = text ?? ""; };
const setHTML = (id, html) => { const el=document.getElementById(id); if (el) el.innerHTML = html ?? ""; };
const byId = id => document.getElementById(id);

function escapeHtml(s){
  var map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
  s = (s == null) ? '' : String(s);
  return s.replace(/[&<>"']/g, function(ch){ return map[ch]; });
}


function asPills(arr){ return (arr||[]).map(x=>`<span class="pill">${escapeHtml(x)}</span>`).join(""); }
function uc(s){ return (s||"").toUpperCase(); }
function safeRender(name, fn){ try{ fn(); }catch(e){ console.warn(`[render:${name}]`, e); } }

/********************
 * Global state
 ********************/
let STATE = null;     // current JSON state
let HERO_SHOWN = true;
let VS_ROWS_FOR_CSV = [];

let VS_FILTER_EL = null;
let VS_CSV_BTN = null;

/********************
 * Markdown + citations
 ********************/
function mdToHtml(md){
  var esc = function(s){
    s = (s == null) ? '' : String(s);
    return s.replace(/[&<>"']/g, function(ch){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'})[ch]; });
  };  
  md = (md || "").replace(/\r\n?/g, "\n");
  // code fences
  md = md.replace(/```([\s\S]*?)```/g, (_, code)=>`<pre class="mono">${esc(code)}</pre>`);
  const lines = md.split("\n");
  const out = []; let inUL = false;
  function closeUL(){ if (inUL){ out.push("</ul>"); inUL=false; } }
  for (let raw of lines){
    const line = raw;
    if (/^#{1,6}\s/.test(line)){
      closeUL();
      const level = Math.min(6, line.match(/^#+/)[0].length);
      const text  = line.replace(/^#{1,6}\s+/, "");
      out.push(`<h${level}>${inlineMd(text, esc)}</h${level}>`);
      continue;
    }
    if (/^[-*]\s+/.test(line)){
      if (!inUL){ out.push("<ul>"); inUL = true; }
      const item = line.replace(/^[-*]\s+/, "");
      out.push(`<li>${inlineMd(item, esc)}</li>`);
      continue;
    }
    if (line.trim() === ""){ closeUL(); out.push(""); continue; }
    closeUL(); out.push(`<p>${inlineMd(line, esc)}</p>`);
  }
  closeUL();
  return out.join("\n").replace(/\n{2,}/g, "\n");
}
function inlineMd(s, esc){
  s = esc(s);
  s = s.replace(/`([^`]+)`/g, '<code class="mono">$1</code>');
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/\*([^*]+)\*/g, '<em>$1</em>');
  s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
  return s;
}

// Parsing Anthropic-like repr for citations
function scanBlocks(src, head){
  const out=[]; let i=0; if (!src) return out;
  while ((i = src.indexOf(head+"(", i)) !== -1){
    let j = i + head.length + 1, depth = 1, q=null, esc=false;
    for (; j < src.length; j++){
      const ch = src[j];
      if (q){ esc ? (esc=false) : (ch==='\\' ? esc=true : (ch===q && (q=null))); continue; }
      if (ch === '"' || ch === "'") { q = ch; continue; }
      if (ch === '(') depth++;
      else if (ch === ')'){ depth--; if (!depth){ j++; break; } }
    }
    out.push(src.slice(i + head.length + 1, j - 1));
    i = j;
  }
  return out;
}
function parseCites(block){
  const chunks = scanBlocks(block, "CitationCharLocation");
  return chunks.map(c => ({
    document_index: Number((c.match(/document_index=(\d+)/)||[])[1]),
    document_title: (c.match(/document_title=['\"]([\s\S]*?)['\"]/)||[])[1] || "",
    cited_text: (c.match(/cited_text=['\"]([\s\S]*?)['\"]/)||[])[1]?.replace(/\\n/g," ") || null
  })).filter(x => Number.isFinite(x.document_index));
}
function parseAnthropicCitationsFromString(rawStr){
  if (!rawStr || typeof rawStr !== "string") return [];
  const tBlocks = scanBlocks(rawStr, "TextBlock");
  const cites = [];
  for (const b of tBlocks){
    const blockCites = parseCites(b) || [];
    for (const c of blockCites){ const cited = (c.cited_text || "").replace(/\s+/g, " ").trim(); cites.push({ document_index: c.document_index, document_title: c.document_title, cited_text: cited }); }
  }
  return cites;
}
function buildBibliography(blocks, st){
  const srcAny = st?.ui?.sources || st?.sources || (Array.isArray(st?.llm_json?.doc_manifest) ? Object.fromEntries(st.llm_json.doc_manifest.map(x => [x.index, { title: x.title, url: x.url }])) : null);
  const lookup = (idx, fallback) => {
    if (!srcAny) return { title: fallback };
    if (Array.isArray(srcAny)) { const s = srcAny[idx]; return s ? { title: s.title||fallback, url: s.url, quote: s.quote } : { title: fallback }; }
    if (typeof srcAny === "object"){ const s = srcAny[idx]; return s ? { title: s.title||fallback, url: s.url, quote: s.quote } : { title: fallback }; }
    return { title: fallback };
  };
  const bib = []; const seen = new Map();
  const key = c => `${c.document_index}|${c.document_title||""}`;
  for (const b of blocks){ for (const c of (b.citations||[])){ const k = key(c); if (!seen.has(k)){ const base = lookup(c.document_index, c.document_title || `Source ${c.document_index}`); const entry = { num: bib.length + 1, document_index: c.document_index, document_title: c.document_title, title: base.title, url: base.url || null, quote: base.quote || null, snippets: [] }; seen.set(k, entry.num); bib.push(entry); } } }
  for (const b of blocks){ for (const c of (b.citations||[])){ const n = seen.get(key(c)); if (!n) continue; const ref = bib[n-1]; const snip = (c.cited_text||"").trim(); if (snip && !(ref.snippets||[]).includes(snip)){ (ref.snippets ||= []).push(snip); if (ref.snippets.length > 3) ref.snippets.length = 3; } } }
  return { bib, numFor(c){ return seen.get(key(c)); } };
}
function replaceCitationPlaceholdersWithHtml(html){
  return String(html||"").replace(/\s?\[\[CITE:(\d+)\]\]/g, (_, n) => ` <sup class="cite" data-cite="${Number(n)}" aria-label="Reference ${Number(n)}">[${Number(n)}]</sup>`);
}
function renderReferencesList(bibliography){
  const el = byId("citations");
  const esc = s => (s ?? "").replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
  const trunc = s => { const t=String(s||""); return t.length<=260?t:t.slice(0,260).replace(/[,;:.\s]+$/,"")+"…"; };
  el.innerHTML = bibliography.map(r=>{
    const title = esc(r.title || `Source ${r.document_index}`);
    const snips = (r.snippets||[]).map(s=>`<div class="muted">“${esc(trunc(s))}”</div>`).join("");
    const quote = r.quote ? `<div class="muted">“${esc(trunc(r.quote))}”</div>` : "";
    const url   = r.url ? `<div class="muted"><a href="${esc(r.url)}" target="_blank" rel="noopener noreferrer">${esc(r.url)}</a></div>` : "";
    return `<li value="${r.num}"><div><strong>${title}</strong></div>${snips}${quote}${url}</li>`;
  }).join("");
}
function wireCitationTooltips(containerEl, bibliography){
  const tip = document.createElement("div"); tip.className = "cite-tip"; document.body.appendChild(tip);
  const esc = s => (s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  const trunc = s => { const t=String(s||""); return t.length<=200?t:t.slice(0,200).replace(/[,;:.\s]+$/,"")+"…"; };
  const contentFor = n => { const ref = bibliography.find(r => r.num===n); if (!ref) return ""; const title = esc(ref.title || ref.document_title || `Source ${ref.document_index}`); const cited = ref.snippets?.[0] ? `<div class="muted" style="margin-top:4px;">“${esc(trunc(ref.snippets[0]))}”</div>` : ""; const quote = ref.quote ? `<div class="muted" style="margin-top:4px;">“${esc(trunc(ref.quote))}”</div>` : ""; const url = ref.url ? `<div style="margin-top:4px;"><a href="${esc(ref.url)}" target="_blank" rel="noopener noreferrer">${esc(ref.url)}</a></div>` : ""; return `<div style="font-weight:600;">[${n}] ${title}</div>${cited}${quote}${url}`; };
  const pos = ev => { const pad=10; tip.style.left = Math.max(8, Math.min(window.innerWidth - tip.offsetWidth - pad, ev.clientX + 14)) + "px"; tip.style.top = Math.max(8, Math.min(window.innerHeight - tip.offsetHeight - pad, ev.clientY + 16)) + "px"; };
  containerEl.querySelectorAll(".cite").forEach(el=>{ const n = Number(el.getAttribute("data-cite")); let pinned=false; el.addEventListener("mouseenter", ev => { if (!pinned){ tip.innerHTML = contentFor(n); tip.classList.add("show"); pos(ev); } }); el.addEventListener("mousemove", pos); el.addEventListener("mouseleave", () => { if (!pinned) tip.classList.remove("show"); }); el.addEventListener("click", ev => { ev.stopPropagation(); if (!pinned){ tip.innerHTML=contentFor(n); tip.classList.add("show"); pos(ev); pinned=true; document.addEventListener("click", ()=>{ pinned=false; tip.classList.remove("show"); }, {once:true}); } else { pinned=false; tip.classList.remove("show"); } }); });
}

/********************
 * Renderers (gene_entities‑first)
 ********************/

 function renderProt(st){
  const mount = document.getElementById("protMount");
  if (!mount) return;

  // Prefer embedded HTML blob if present
  const html = st?.prot_html;

  // Optional fallbacks if your JSON uses different keys:
  // - prot_iframe_url: a full URL to load in an iframe
  // - pdb_id: render a lightweight PDBe Mol* embed (no server needed)
  const iframeUrl = st?.prot_iframe_url;
  const pdbId     = st?.pdb_id;

  // clear previous
  mount.innerHTML = "";

  // Nothing to show?
  if (!html && !iframeUrl && !pdbId){
    return (document.getElementById("protCard").style.display = "none");
  }

  // Build iframe + optional save button
  const frame = document.createElement("iframe");
  frame.className = "prot-frame";
  frame.setAttribute("sandbox", "allow-scripts");
  frame.setAttribute("referrerpolicy", "no-referrer");

  if (html && typeof html === "string" && html.trim()){
    frame.srcdoc = html;

    const saveBtn = document.createElement("button");
    saveBtn.className = "mini";
    saveBtn.textContent = "Save HTML";
    saveBtn.style.margin = "6px 0 10px";
    saveBtn.onclick = () => {
      const blob = new Blob([html], { type: "text/html;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "protein_view.html"; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 800);
    };
    mount.appendChild(saveBtn);
  } else if (iframeUrl){
    // external viewer you provide
    frame.src = iframeUrl;
  } else if (pdbId){
    // super-light PDBe Mol* viewer (no external JS — it’s their hosted viewer)
    // theme will still postMessage (below), which many viewers ignore safely.
    frame.src = `https://www.ebi.ac.uk/pdbe/entry-files/molstar.html?structureId=${encodeURIComponent(pdbId)}`;
  }

  mount.appendChild(frame);
  document.getElementById("protCard").style.display = "block";

  // Theme sync (dark/light toggle): send a message the viewer can ignore if unsupported
  const isLight = document.body.classList.contains("light");
  // fire once after load
  frame.addEventListener("load", () => {
    frame.contentWindow?.postMessage({ type: "theme", theme: isLight ? "light" : "dark" }, "*");
  });
}


 function renderQuestion(st){
  var msgs = (st && st.messages) || [];
  var lastUser = null;
  for (var i = msgs.length - 1; i >= 0; i--){
    if (msgs[i] && msgs[i].role === "user"){ lastUser = msgs[i]; break; }
  }
  var q = (lastUser && lastUser.content) || (st && st.prompt) || "";
  setText("question", q);
  setText("questionTitle", "Question");
}

function renderAnswerAndCitations(st){
  const answerEl = byId("answer"); const refsEl = byId("citations"); answerEl.innerHTML = ""; refsEl.innerHTML = "";
  const base = (st?.llm_json?.answer || (Array.isArray(st?.messages)?(st.messages.filter(m=>m.role==='assistant' && m.content).at(-1)?.content||""):"") || "").trim();
  if (!base){ hide("answerCard"); return; }
  const raw = st?.llm_json?.citations || st?.ui?.llm_raw_repr || st?.llm_raw_repr || "";
  const cites = parseAnthropicCitationsFromString(raw);
  if (!cites.length){ answerEl.innerHTML = mdToHtml(base); show("answerCard"); refsEl.innerHTML = ""; return; }
  const { bib, numFor } = buildBibliography([{ text:"", citations: cites }], st);
  function insertCitationsIntoText(text, citations, numFor){
    let out = text; const lower = () => out.toLowerCase();
    function tryInsert(snippet, n){ if (!snippet) return false; const sn = snippet.replace(/\s+/g," ").trim(); if (!sn) return false; let idx = lower().indexOf(sn.toLowerCase()); if (idx !== -1){ const end = idx + sn.length; out = out.slice(0, end) + ` [[CITE:${n}]]` + out.slice(end); return true; } const words = sn.split(" ").filter(Boolean); const short = words.slice(0, Math.min(12, words.length)).join(" "); if (short.length >= 20){ idx = lower().indexOf(short.toLowerCase()); if (idx !== -1){ const end = idx + short.length; out = out.slice(0, end) + ` [[CITE:${n}]]` + out.slice(end); return true; } } return false; }
    function fallbackInsert(cited, n){
      // Split into sentences without lookbehind; keeps punctuation
      var sents = out.match(/[^.!?]+(?:[.!?]+|$)/g) || [out];
      var keys = (cited||"").toLowerCase().split(/\s+/).filter(function(w){ return w.length>3; });
      var best = -1, scoreBest = 0, posEnd = 0;
    
      for (var i=0; i<sents.length; i++){
        var sLow = sents[i].toLowerCase();
        var score = 0;
        for (var k=0; k<keys.length; k++) if (sLow.indexOf(keys[k]) !== -1) score++;
        if (score > scoreBest){ scoreBest = score; best = i; }
      }
      if (best >= 0){
        for (var i2=0,p=0; i2<=best; i2++){ p += sents[i2].length; posEnd = p; }
        out = out.slice(0, posEnd) + " [[CITE:"+n+"]]" + out.slice(posEnd);
      } else {
        out += " [[CITE:"+n+"]]";
      }
    }
        for (const c of citations){ const n = numFor(c); if (!n) continue; if (!tryInsert(c.cited_text, n)) fallbackInsert(c.cited_text, n); }
    return out; }
  const annotated = insertCitationsIntoText(base, cites, numFor);
  let html = mdToHtml(annotated); html = replaceCitationPlaceholdersWithHtml(html);
  answerEl.innerHTML = html; show("answerCard"); renderReferencesList(bib); wireCitationTooltips(answerEl, bib);
}
  function renderEntities(st){
    function escapeHtml(s){ return String(s??"").replace(/[&<>"']/g,ch=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[ch])); }
    function asPills(arr){ return (arr||[]).filter(Boolean).map(x=>`<span class="pill">${escapeHtml(String(x))}</span>`).join(" "); }
  
    // Genes/entities
    var ge = (st && st.gene_entities && typeof st.gene_entities === "object") ? Object.keys(st.gene_entities) : [];
    var genes = ge.length ? ge : (st && st.genes ? st.genes : []);
    var html = "";
    if (genes && genes.length){
      html += asPills(genes);
    }
  
    // Tools used (look in a bunch of likely places)
    var tools = [];
    var candidates = [
      st?.tools_used, st?.ui?.tools_used, st?.llm_json?.tools_used,
      st?.tools, st?.ui?.tools, st?.pipeline?.tools, st?.tool_calls
    ];
    candidates.forEach(function(t){
      if (!t) return;
      if (Array.isArray(t)){
        t.forEach(function(x){
          if (!x) return;
          if (typeof x === "string") tools.push(x);
          else if (typeof x === "object"){
            tools.push(x.name || x.tool || x.id || x.type);
          }
        });
      } else if (typeof t === "object"){
        Object.keys(t).forEach(function(k){ tools.push(k); });
      } else if (typeof t === "string"){
        tools = tools.concat(t.split(/[,\s]+/));
      }
    });
    tools = Array.from(new Set(tools.filter(Boolean)));
  
    if (tools.length){
      if (html) html += '<div style="height:6px"></div>';
      html += '<div class="muted" style="margin-bottom:4px;">Tools used</div>';
      html += asPills(tools);
    }
  
    if (html){
      document.getElementById("entities").innerHTML = html;
      document.getElementById("entitiesCard").style.display = "block";
    } else {
      document.getElementById("entitiesCard").style.display = "none";
      document.getElementById("entities").innerHTML = "";
    }
  }
  
  function parsePandasLikeMRTable(txt){
    // Accepts the pandas DataFrame pretty-print string and returns {cols, rows}
    if (!txt || typeof txt !== "string") return { cols: [], rows: [] };
    // strip the trailing "[N rows x M columns]" line if present
    const lines = txt.split(/\r?\n/).filter(l => l.trim() && !/^\[\d+\s+rows\s+x\s+\d+\s+columns\]$/i.test(l.trim()));
  
    if (!lines.length) return { cols: [], rows: [] };
  
    // First non-empty is header; collapse 2+ spaces to tabs to preserve tokens with single spaces
    const header = lines[0].trim().replace(/\s{2,}/g, "\t").split("\t").map(s => s.trim());
    // Some DF prints include an "..." column where middle cols are elided; we’ll ignore it.
    const keep = ["exposure","outcome","method","Q_df","Q_pval","OR_95CI"];
    const colIdx = header.reduce((acc, name, i) => { acc[name] = i; return acc; }, {});
    const cols = keep.filter(c => colIdx[c] != null);
  
    const rows = [];
    for (let i = 1; i < lines.length; i++){
      let raw = lines[i].trim();
      // collapse 2+ spaces to tabs
      let parts = raw.replace(/\s{2,}/g, "\t").split("\t");
      // many pandas prints include a leading row index, drop it
      if (parts.length && /^\d+$/.test(parts[0])) parts.shift();
      // also drop an ellipsis column if present
      parts = parts.filter(p => p.trim() !== "...");
      // build the row in our kept column order
      const row = cols.map(c => (parts[colIdx[c]] ?? "—"));
      rows.push(row);
    }
    return { cols, rows };
  }
  
  function renderTwoSampleMR(st){
    const mount = document.getElementById("tsmr");
    const card  = document.getElementById("tsmrCard");
    if (!mount || !card) return;
  
    const block = st?.two_sample_mr_ui;
    if (!block || typeof block !== "object" || !Object.keys(block).length){
      card.style.display = "none";
      mount.innerHTML = "";
      return;
    }
  
    const sections = [];
    Object.entries(block).forEach(([key, obj]) => {
      if (!obj || typeof obj !== "object") return;
      const title = key;
      const cohort = obj.cohort ? `<span class="pill">${escapeHtml(String(obj.cohort))}</span>` : "";
      const gene   = obj.gene   ? `<span class="pill">Gene: ${escapeHtml(String(obj.gene))}</span>` : "";
      const cis    = (obj.cis===true || obj.cis==="true") ? `<span class="pill">cis</span>` : `<span class="pill ghost">trans</span>`;
  
      const sum    = obj.summary_text ? `<div class="mr-sum">${escapeHtml(String(obj.summary_text))}</div>` : "";
      const parsed = parsePandasLikeMRTable(String(obj.results_table || ""));
  
      // fallback: nothing parsed
      let tableHTML = `<div class="muted">No MR results table available.</div>`;
      if (parsed.cols.length && parsed.rows.length){
        const thead = `<thead><tr>${parsed.cols.map(c => `<th>${escapeHtml(c)}</th>`).join("")}</tr></thead>`;
        const tbody = `<tbody>${
          parsed.rows.map(r => `<tr>${r.map(v => `<td title="${escapeHtml(String(v))}">${escapeHtml(String(v))}</td>`).join("")}</tr>`).join("")
        }</tbody>`;
  
        // CSV
        const csv = [
          parsed.cols.join(","),
          ...parsed.rows.map(r => r.map(x => {
            const s = String(x ?? "");
            return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
          }).join(","))
        ].join("\n");
  
        const btnId = `mrCsv_${Math.random().toString(36).slice(2,9)}`;
        tableHTML = `
          <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px;">
            <div class="muted">${parsed.rows.length} row${parsed.rows.length===1?"":"s"} • columns: ${parsed.cols.length}</div>
            <button id="${btnId}" class="ghost">Download CSV</button>
          </div>
          <div class="scroll"><table>${thead}${tbody}</table></div>
        `;
  
        // defer wiring after adding to DOM (we'll hook it below)
        sections.push({ html:
          `<div class="mr-block">
             <div class="mr-head"><strong>${escapeHtml(title)}</strong> ${cohort} ${gene} ${cis}</div>
             ${sum}
             ${tableHTML}
           </div>`,
          btnId, csv
        });
        return;
      }
  
      sections.push({ html:
        `<div class="mr-block">
           <div class="mr-head"><strong>${escapeHtml(title)}</strong> ${cohort} ${gene} ${cis}</div>
           ${sum}
           ${tableHTML}
         </div>`
      });
    });
  
    mount.innerHTML = sections.map(s => s.html).join("");
    card.style.display = "block";
  
    // wire CSV buttons
    sections.forEach(s => {
      if (!s.btnId || !s.csv) return;
      const btn = document.getElementById(s.btnId);
      if (!btn) return;
      btn.addEventListener("click", () => {
        const blob = new Blob([s.csv], { type: "text/csv;charset=utf-8" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "two_sample_mr_results.csv";
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 500);
      });
    });
  }

  
function renderGeneSummary(st){
  const ge = st?.gene_entities && typeof st.gene_entities === "object" ? st.gene_entities : {};
  const blocks = Object.entries(ge).map(([gene, obj])=>{
    if (!obj || typeof obj !== 'object') return '';
    const id = obj.identifiers||{}; const sym = id.symbol || gene; const ens = id.ensembl_id||''; const uni = id.uniprot_id||''; const entrez = id.entrez_id||''; const aliases = (id.aliases||[]).slice(0,10).filter(Boolean);
    const tx = obj.transcriptome||{}; const nTx = tx.transcript_count ?? (tx.transcripts ? Object.keys(tx.transcripts).length : undefined);
    const spanMin = tx.median_transcript_span_bp || tx.min_transcript_span_bp; const spanMax = tx.max_transcript_span_bp;
    const varCount = obj.variants && typeof obj.variants==='object' ? Object.keys(obj.variants).length : 0;
    const header = `<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;"><strong>${escapeHtml(uc(sym))}</strong><span class="muted">${ens?`• ${escapeHtml(ens)}`:''}${entrez?` • Entrez:${escapeHtml(entrez)}`:''}${uni?` • UniProt:${escapeHtml(uni)}`:''}</span></div>`;
    const meta = `<div class="muted" style="margin-top:4px;">${nTx!=null?`Transcripts: ${nTx}`:''}${(spanMin||spanMax)?` • Span: ${escapeHtml(String(spanMin||'?'))}–${escapeHtml(String(spanMax||'?'))} bp`:''} • Variants in state: ${varCount}</div>`;
    const aliasHtml = aliases.length? `<div class="muted" style="margin-top:4px;">Aliases</div><div>${asPills(aliases)}</div>` : '';
    return `<div style="margin-bottom:12px;">${header}${meta}${aliasHtml}</div>`;
  }).join("");
  if (blocks.trim()){ setHTML("geneSummary", blocks); show("geneSummaryCard"); } else hide("geneSummaryCard");
}

// Variant Summary — strictly from gene_entities
function pickBuild(loc_by_build, want){
  if (!loc_by_build || typeof loc_by_build !== "object") return null;
  var keys = Object.keys(loc_by_build);
  var wantLC = String(want).toLowerCase();
  var k = keys.find(k => String(k).toLowerCase().startsWith(wantLC));
  if (!k && wantLC === "grch38") k = keys.find(k => String(k).toLowerCase().startsWith("grch37"));
  if (!k && wantLC === "grch37") k = keys.find(k => String(k).toLowerCase().startsWith("grch38"));
  return k ? (loc_by_build[k] || null) : null;
}
function normChrom(c){
  if (!c) return "";
  c = String(c);
  if (/^chr/i.test(c)) c = c.replace(/^chr/i,'');
  if (/^m(t)?$/i.test(c)) return "MT";
  return c;
}
function compactKV(obj, keys){ if (!obj || typeof obj !== "object") return ""; const parts = []; for (const k of keys){ const v = obj[k]; if (v == null) continue; parts.push(`${k}:${typeof v === "number" ? (Math.abs(v) !== 0 && (Math.abs(v) < 1e-3 || Math.abs(v) >= 1e5) ? v.toExponential(3) : v.toFixed(3)) : String(v)}`); } return parts.join(", "); }
function topExprString(exRec){ if (!exRec || typeof exRec !== "object") return ""; const flat = []; for (const [k,v] of Object.entries(exRec)){ let val = null; if (typeof v === "number") val = v; else if (v && typeof v === "object" && typeof v.z === "number") val = v.z; if (val == null) continue; flat.push({k, z: Number(val)}); } flat.sort((a,b)=>Math.abs(b.z)-Math.abs(a.z)); return flat.slice(0,3).map(e => `${e.k}:${e.z.toFixed(2)}`).join(", "); }

function pickFirst(){ for (var i=0;i<arguments.length;i++){ var v=arguments[i]; if (v!==undefined && v!==null && v!=="") return v; } return ""; }
function parseChrPos(s){
  s = String(s || "");
  var m = s.match(/(?:chr)?([0-9]+|X|Y|MT)[:\s]+(\d+)/i);
  return m ? { chrom: m[1], pos: Number(m[2]) } : {};
}
function toStrAllele(x){
  if (x == null) return "";
  if (Array.isArray(x)) return x.join(",");
  return String(x);
}

// Accept gene_entities OR derive a gene->variants map from other shapes.
function getGeneMap(st){
  // Preferred
  if (st?.gene_entities && typeof st.gene_entities === "object" && Object.keys(st.gene_entities).length){
    return st.gene_entities;
  }

  // Fallbacks: variant_entities / variants / variant_list (array or dict)
  const raw = st?.variant_entities ?? st?.variants ?? st?.variant_list ?? [];
  const arr  = Array.isArray(raw) ? raw : Object.values(raw || {});
  const gm   = {};

  for (const item of arr){
    const geneField = item.genes ?? item.gene_symbols ?? item.gene ?? item.symbol ?? [];
    const genes = Array.isArray(geneField)
      ? geneField
      : String(geneField || "").split(/[;,|]/).map(s => s.trim()).filter(Boolean);

    if (!genes.length) genes.push("NA");

    for (const g of genes){
      const G = (gm[g] ||= { variants: {} });
      const id =
        item.rsID || item.rsid || item.id || item.variant_id ||
        [item.chrom||item.chr, item.pos||item.position||item.coord].filter(Boolean).join(":") ||
        Math.random().toString(36).slice(2,9);

      // Normalize per-gene context/traits into the expected nesting
      const pgc = (item.per_gene_context && item.per_gene_context[g]) || item.per_gene || {};
      const pgt = (item.per_gene_traits  && item.per_gene_traits[g])  || (item.traits_by_gene && item.traits_by_gene[g]) || {};

      G.variants[id] = {
        ...item,
        per_gene_context: { ...(item.per_gene_context||{}), [g]: pgc },
        per_gene_traits : { ...(item.per_gene_traits ||{}), [g]: pgt }
      };
    }
  }
  return gm;
}

function buildVariantRowsFromGeneEntities(st){
  var rows = []; var ge = getGeneMap(st);   
  if (!ge || typeof ge !== "object") return rows;

  var seiG = st?.sei_predictions || st?.variant_sei || {};
  var amG  = st?.alphamissense_predictions || st?.alphamissense || {};
  var exprG= st?.expression_preds_variant_table || st?.variant_expression || {};

  for (var gene in ge){
    var gObj = ge[gene]; if (!gObj || typeof gObj !== "object") continue;
    var vdict = gObj.variants; if (!vdict || typeof vdict !== "object") continue;

    for (var k in vdict){
      var v = vdict[k] || {};
      var rsid = v.rsID || v.rsid || v.id || "";

      var loc38 = pickBuild(v.loc_by_build, "GRCh38") || {};
      var loc37 = pickBuild(v.loc_by_build, "GRCh37") || {};

      // chrom + positions with robust fallbacks
      var chrom = pickFirst(loc38.chrom, loc37.chrom, loc38.chr, loc37.chr, v.chrom, v.chr);
      var pos38 = pickFirst(loc38.pos, loc38.position, v.pos38, v.position_38, v.hg38_position);
      var pos37 = pickFirst(loc37.pos, loc37.position, v.pos37, v.position_37, v.hg19_position);

      if (!chrom || (!pos38 && !pos37)){
        var guess = parseChrPos(v.position || v.locus || v.coord || "");
        if (!chrom && guess.chrom) chrom = guess.chrom;
        if (!pos38 && guess.pos) pos38 = guess.pos;
      }

      // --- chrom + positions (robust) ---
var chrom = normChrom(pickFirst(
  loc38.chrom, loc37.chrom, loc38.chr, loc37.chr,
  loc38.chromosome, loc37.chromosome, v.chrom, v.chr
));
var pos38 = pickFirst(loc38.pos, loc38.position, loc38.hg38_pos, v.pos38, v.position_38, v.hg38_position);
var pos37 = pickFirst(loc37.pos, loc37.position, loc37.hg19_pos, v.pos37, v.position_37, v.hg19_position);

// also parse "locus: chr16:538..." if present
if (loc38.locus || loc38.coordinate || loc38.coord){
  var g38 = parseChrPos(loc38.locus || loc38.coordinate || loc38.coord);
  if (!chrom && g38.chrom) chrom = normChrom(g38.chrom);
  if (!pos38 && g38.pos) pos38 = g38.pos;
}
if (loc37.locus || loc37.coordinate || loc37.coord){
  var g37 = parseChrPos(loc37.locus || loc37.coordinate || loc37.coord);
  if (!chrom && g37.chrom) chrom = normChrom(g37.chrom);
  if (!pos37 && g37.pos) pos37 = g37.pos;
}
// variant-level locus fallback
if ((!chrom || (!pos38 && !pos37)) && (v.position || v.locus || v.coord)){
  var gv = parseChrPos(v.position || v.locus || v.coord);
  if (!chrom && gv.chrom) chrom = normChrom(gv.chrom);
  if (!pos38 && gv.pos) pos38 = gv.pos;
}

// --- Ref/Alt (robust) ---
var refStr = toStrAllele(pickFirst(
  loc38.ref, loc37.ref,
  loc38.ref_allele, loc37.ref_allele,
  v.ref, v.ref_allele, v.reference, v.reference_allele
));
var altStr = toStrAllele(pickFirst(
  loc38.alt, loc37.alt,
  loc38.alt_allele, loc37.alt_allele,
  loc38.alts, loc37.alts,
  v.alt, v.alt_allele, v.alternate, v.alternate_allele, v.alts
));
// if still empty, try alleles array or "C/T" string
if (!refStr && !altStr){
  var alle = pickFirst(loc38.alleles, loc37.alleles, v.alleles);
  if (Array.isArray(alle) && alle.length >= 2){
    refStr = toStrAllele(alle[0]);
    altStr = toStrAllele(alle.slice(1));
  } else if (typeof v.allele === "string" && v.allele.includes("/")){
    var parts = v.allele.split("/");
    refStr = parts[0];
    altStr = parts.slice(1).join(",");
  } else if (typeof loc38.ref_alt === "string" && loc38.ref_alt.includes("/")){
    var p38 = loc38.ref_alt.split("/");
    refStr = p38[0]; altStr = p38.slice(1).join(",");
  }
}

      var ctxRec = (v.per_gene_context && v.per_gene_context[gene]) || {};
      var context   = ctxRec.context || "";
      var category  = ctxRec.variant_category || ctxRec.category || "";

      var consequence = v.consequence || v.most_severe_consequence || v.vep_consequence || "";
      var clinvar     = v.clinvar_significance || v.clin_sig || v.clinvar || "";

      // Predictions
      var seiStr = "";
      var seiLocal = v.sei || v.functional_predictions?.SEI || v.predictions?.sei;
      if (typeof seiLocal === "number") seiStr = seiLocal.toFixed(3);
      else if (seiLocal && typeof seiLocal === "object") seiStr = compactKV(seiLocal, ["delta","max_delta","score","pred","chromatin"]);
      else if (rsid && seiG?.[gene]?.[rsid] != null){
        var sg = seiG[gene][rsid];
        seiStr = (typeof sg === "number") ? sg.toFixed(3) : compactKV(sg, ["delta","max_delta","score","pred","chromatin"]);
      }

      var amStr = "";
      var amLocal = v.alphamissense || v.predictions?.alphamissense || v.am;
      if (typeof amLocal === "number") amStr = amLocal.toFixed(3);
      else if (amLocal && typeof amLocal === "object") amStr = compactKV(amLocal, ["pathogenicity","score","p","label"]);
      else if (rsid && amG?.[gene]?.[rsid] != null){
        var ag = amG[gene][rsid];
        amStr = (typeof ag === "number") ? ag.toFixed(3) : compactKV(ag, ["pathogenicity","score","p","label"]);
      }

      var exprStr = "";
      var exprLocal = v.expression || v.predictions?.expression || v.expr;
      if (exprLocal) exprStr = topExprString(exprLocal);
      else if (rsid && exprG?.[gene]?.[rsid]) exprStr = topExprString(exprG[gene][rsid]);

      // Traits
      var topTrait = "", topP = null, topRisk = null;
      var traitsRec = (v.per_gene_traits && v.per_gene_traits[gene]) || {};
      var traitNames = [];
      for (var t in traitsRec){
        traitNames.push(t);
        var p = Number(traitsRec[t]?.p_value);
        if (Number.isFinite(p) && (topP===null || p<topP)){ topP=p; topTrait=t; topRisk=traitsRec[t]?.risk_score ?? null; }
      }

      // GnomAD alt AF (if present)
      var gnomadAF = null;
      var altSet = new Set((altStr||"").split(",").filter(Boolean));
      (v.af_freqs || []).forEach(function(af){
        if (af?.study_name === "GnomAD_genomes"){
          var ins = af?.observation?.inserted_sequence;
          if (ins && altSet.has(ins)) gnomadAF = af.allele_frequency ?? gnomadAF;
        }
      });

      rows.push({
        gene, rsid, chrom,
        pos38, pos37,
        ref: refStr, alt: altStr,
        context, category, consequence, clinvar,
        sei: seiStr, alphamissense: amStr, expr_preds: exprStr,
        top_trait: topTrait, top_p: topP, top_risk: topRisk,
        gnomad_alt_af: gnomadAF,
        traits_list: traitNames.join("; ")
      });
    }
  }

  rows.sort(function(a,b){
    var g = String(a.gene).localeCompare(String(b.gene));
    if (g!==0) return g;
    var pa = (a.top_p==null?Infinity:a.top_p), pb = (b.top_p==null?Infinity:b.top_p);
    return pa - pb;
  });

  return rows;
}

function collectVariantLikeRecords(st){
  // Returns an array of raw variant objects from multiple possible shapes.
  const out = [];

  // 1) gene_entities.*.variants { rsid: {...} }
  const ge = st?.gene_entities;
  if (ge && typeof ge === "object"){
    for (const [g, gObj] of Object.entries(ge)){
      const vdict = gObj?.variants;
      if (vdict && typeof vdict === "object"){
        for (const [k,v] of Object.entries(vdict)){
          if (v && typeof v === "object") out.push({__gene:g, __key:k, ...v});
        }
      }
    }
  }

  // 2) variant_entities: []  (array)
  const ve = st?.variant_entities;
  if (Array.isArray(ve)){
    for (const v of ve){
      if (v && typeof v === "object") out.push(v);
    }
  }

  // 3) variants: []  (array form)
  if (Array.isArray(st?.variants)){
    for (const v of st.variants){
      if (v && typeof v === "object") out.push(v);
    }
  }

  // 4) variants: {}  (dict form)
  if (st?.variants && typeof st.variants === "object" && !Array.isArray(st.variants)){
    for (const [k,v] of Object.entries(st.variants)){
      if (v && typeof v === "object") out.push({__key:k, ...v});
    }
  }

  return out;
}

function renderVariantSummary(data, mountId = "variantSummary") {
  const root = document.getElementById(mountId);
  if (!root) return;

  // Helpers
  const safe = (v) => (v === undefined || v === null || v === "" ? "—" : v);
  const getLoc = (v, buildKey) => {
    const b = v?.loc_by_build?.[buildKey];
    if (!b) return { chrom: "—", pos: "—", ref: "—", alt: "—" };
    const ref = Array.isArray(b.ref) ? b.ref.join(",") : safe(b.ref);
    const alt = Array.isArray(b.alt) ? b.alt.join(",") : safe(b.alt);
    return { chrom: safe(b.chrom), pos: safe(b.pos), ref: safe(ref), alt: safe(alt) };
  };
  const getTopTraitForGene = (v) => {
    // Pick first gene with a valid per_gene_traits entry, then smallest p_value
    const gene = (v.genes_related_to && v.genes_related_to[0]) ||
                 Object.keys(v.per_gene_traits || {})[0];
    if (!gene) return { gene: "—", trait: "—", p: "—" };

    const entries = v.per_gene_traits?.[gene] || {};
    let bestTrait = "—", bestP = Infinity;
    for (const [trait, obj] of Object.entries(entries)) {
      const p = Number(obj?.p_value);
      if (!Number.isNaN(p) && p < bestP) {
        bestP = p;
        bestTrait = trait;
      }
    }
    return { gene: safe(gene), trait: bestTrait, p: bestP === Infinity ? "—" : String(bestP) };
  };
  const getCategoryContext = (v, gene) => {
    const ctx = v.per_gene_context?.[gene] || {};
    return {
      category: safe(ctx.variant_category || v.category || "—"),
      context:  safe(ctx.context || v.context || "—"),
    };
  };
  const getAlphaMissense = (v, gene) => {
    const call = v.functional_predictions?.[gene]?.AlphaMissense;
    if (!call) return "—";
    return Array.isArray(call) ? call.join(", ") : String(call);
  };
  const getGnomadAF = (v) => {
    const hit = (v.af_freqs || []).find(a => /gnomad/i.test(a.study_name || ""));
    return hit ? (typeof hit.allele_frequency === "number" ? hit.allele_frequency.toFixed(6) : safe(hit.allele_frequency)) : "—";
  };

  // Rows
  const variantsObj = data?.variants && typeof data.variants === "object" ? data.variants : {};
  const rsids = Object.keys(variantsObj);
  const rows = rsids.map(rsid => {
    const v = variantsObj[rsid] || {};
    const { gene, trait: topTrait, p: topP } = getTopTraitForGene(v);
    const { category, context } = getCategoryContext(v, gene);
    const b38 = getLoc(v, "GRCh38.p14");
    const b37 = getLoc(v, "GRCh37.p13");
    return {
      gene,
      rsid,
      chrom: b38.chrom !== "—" ? b38.chrom : b37.chrom,
      grch38: b38.pos,
      grch37: b37.pos,
      ref: b38.ref !== "—" ? b38.ref : b37.ref,
      alt: b38.alt !== "—" ? b38.alt : b37.alt,
      context,
      category,
      consequence: safe(v.consequence),
      clinvar: safe(v.clinvar),
      sei: safe(v.functional_predictions?.SEI),
      alpha: getAlphaMissense(v, gene),
      expr: safe(v.expr_preds),
      topTrait: safe(topTrait),
      topP: safe(topP),
      gnomadAF: getGnomadAF(v),
      traits: Array.isArray(v.traits) ? v.traits.join("; ") : safe(v.traits),
      usedTools: Array.isArray(v.tools_run) ? v.tools_run.join(", ") : "—",
    };
  });

  // Header + CSV
  const cols = [
    "Gene","RSID","Chrom","GRCh38 pos","GRCh37 pos","Ref","Alt","Context","Category",
    "Consequence","ClinVar","SEI","AlphaMissense","Expr preds",
    "Top trait (by p)","Top p-value","GnomAD alt AF","Traits"
  ];

  const toCSV = () => {
    const header = cols.join(",");
    const body = rows.map(r => [
      r.gene,r.rsid,r.chrom,r.grch38,r.grch37,r.ref,r.alt,r.context,r.category,
      r.consequence,r.clinvar,r.sei,r.alpha,r.expr,r.topTrait,r.topP,r.gnomadAF,
      `"${(r.traits || "").replaceAll(`"`,`""`)}"`
    ].map(x => (x ?? "—")).join(",")).join("\n");
    return header + "\n" + body;
  };

  // Styles to prevent overlap
  const tableStyles = `
    #${mountId} .vs-wrap { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    #${mountId} .vs-head { display:flex; align-items:center; gap:.75rem; margin: .25rem 0 .5rem; }
    #${mountId} .vs-btn { border:1px solid #ddd; padding:.4rem .6rem; border-radius:.5rem; cursor:pointer; background:#fff; }
    #${mountId} table { width:100%; border-collapse: collapse; table-layout: fixed; }
    #${mountId} th, #${mountId} td { border:1px solid #eee; padding:.4rem .5rem; vertical-align: top; text-align:left; }
    #${mountId} th { position:sticky; top:0; background:#fafafa; z-index:1; }
    #${mountId} td, #${mountId} th { overflow-wrap: anywhere; word-break: break-word; white-space: normal; }
    #${mountId} .subtle { color:#666; font-size:.85em; margin-top:.25rem; }
  `;
  const styleTag = document.createElement("style");
  styleTag.textContent = tableStyles;

  const title = `Variant Summary`;
  const count = `${rows.length || 0} variants`;
  const csvName = "variant_summary.csv";

  const dlCSV = () => {
    const blob = new Blob([toCSV()], { type: "text/csv;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = csvName;
    a.click();
    URL.revokeObjectURL(a.href);
  };

  // Build HTML
  const headerHTML = `
    <div class="vs-head">
      <h3 style="margin:0">${title}</h3>
      <button class="vs-btn" id="vsDownload">Download CSV</button>
      <div style="color:#555">• ${count}</div>
    </div>
  `;

  const thead = `
    <thead>
      <tr>${cols.map(c => `<th>${c}</th>`).join("")}</tr>
    </thead>
  `;

  const tbody = `
    <tbody>
      ${rows.map(r => `
        <tr>
          <td>${r.gene}<div class="subtle">Tools: ${r.usedTools}</div></td>
          <td>${r.rsid}</td>
          <td>${r.chrom}</td>
          <td>${r.grch38}</td>
          <td>${r.grch37}</td>
          <td>${r.ref}</td>
          <td>${r.alt}</td>
          <td>${r.context}</td>
          <td>${r.category}</td>
          <td>${r.consequence}</td>
          <td>${r.clinvar}</td>
          <td>${r.sei}</td>
          <td>${r.alpha}</td>
          <td>${r.expr}</td>
          <td>${r.topTrait}</td>
          <td>${r.topP}</td>
          <td>${r.gnomadAF}</td>
          <td>${r.traits}</td>
        </tr>
      `).join("")}
    </tbody>
  `;

  root.innerHTML = `<div class="vs-wrap">${headerHTML}<table>${thead}${tbody}</table></div>`;
  // Attach styles & wire buttons
  root.prepend(styleTag);
  const dlBtn = document.getElementById("vsDownload");
  dlBtn?.addEventListener("click", dlCSV, { once: false });
}

function renderEvidence(st){
  const ev = st?.evidence || st?.ui?.evidence || st?.llm_json?.evidence || st?.sources || [];
  const items = [];
  const pushItem = (obj) => { if (typeof obj === "string") { items.push(`<li>${escapeHtml(obj)}</li>`); return; } if (!obj || typeof obj !== "object") return; const title = obj.title ? `<div><strong>${escapeHtml(obj.title)}</strong></div>` : ""; const quote = obj.quote ? `<div class=\"muted\">“${escapeHtml(obj.quote)}”</div>` : ""; const url = obj.url ? `<div class=\"muted\"><a href=\"${escapeHtml(obj.url)}\" target=\"_blank\" rel=\"noopener noreferrer\">${escapeHtml(obj.url)}</a></div>` : ""; items.push(`<li>${title}${quote}${url}</li>`); };
  if (Array.isArray(ev)) ev.forEach(pushItem); else if (typeof ev === "object") Object.values(ev).forEach(v => { if (Array.isArray(v)) v.forEach(pushItem); else pushItem(v); });
  if (items.length){ setHTML("evidence", `<ol class="refs-list">${items.join("")}</ol>`); show("evidenceCard"); } else hide("evidenceCard");
}

function renderRaw(st){ const json = JSON.stringify(st ?? {}, null, 2); if (json && json !== "{}"){ setText("raw", json); show("rawCard"); } else hide("rawCard"); }

/********************
 * IO helpers (no auto-hydrate)
 ********************/
async function fetchState(){ try{ const res = await fetch("state", { cache:"no-store" }); if (!res.ok) return null; return await res.json(); } catch{ return null; } }
async function runServer(q){ try{ await fetch("run?q=" + encodeURIComponent(q), { cache:"no-store" }); } catch {} STATE = await fetchState(); await refresh(q); }

/********************
 * Page wiring + refresh
 ********************/
async function refresh(qOverride){
  if (!STATE) return;
  if (HERO_SHOWN){ HERO_SHOWN = false; hide("hero"); show("grid"); show("toolbar"); }
  if (qOverride) setText("question", qOverride);
  safeRender("question", ()=>renderQuestion(STATE));
  safeRender("answer", ()=>renderAnswerAndCitations(STATE));
  safeRender("entities", ()=>renderEntities(STATE));
  safeRender("geneSummary", ()=>renderGeneSummary(STATE));
  safeRender("variants", ()=>renderVariantSummary(STATE));
  safeRender("protein",    ()=>renderProt(STATE)); 
  safeRender("twoSampleMR", () => renderTwoSampleMR(STATE));
  safeRender("evidence", ()=>renderEvidence(STATE));
  safeRender("raw", ()=>renderRaw(STATE));
}

// Theme toggle
byId("themeToggle")?.addEventListener("click", () => { document.body.classList.toggle("light"); });

// Run actions
function wireRun(button, input){ if (!button || !input) return; const go = () => { const q = input.value.trim(); if (!q){ input.focus(); return; } runServer(q); }; button.addEventListener("click", go); input.addEventListener("keydown", e => { if (e.key === "Enter") go(); }); }
wireRun(byId("runBtn"), byId("q")); wireRun(byId("runBtn2"), byId("q2"));

// Load JSON from file inputs
function wireJsonFile(input){ if (!input) return; input.addEventListener("change", () => { const f = input.files?.[0]; if (!f) return; const reader = new FileReader(); reader.onload = () => { try { STATE = JSON.parse(String(reader.result || "{}")); refresh(); } catch { alert("Invalid JSON file."); } }; reader.readAsText(f); input.value = ""; }); }
wireJsonFile(byId("jsonFile")); wireJsonFile(byId("jsonFile2"));

// Demo selector (manual only)
byId("demoSelect")?.addEventListener("change", () => { const v = byId("demoSelect").value; if (!v) return; fetch(v, { cache:"no-store" }).then(r=>r.ok?r.json():null).then(j=>{ if(!j){ alert("Could not load demo JSON."); return; } STATE=j; refresh(); }).catch(()=>alert("Could not load demo JSON.")); });

// Download current state
byId("downloadBtn")?.addEventListener("click", () => { if (!STATE){ alert("No JSON loaded yet."); return; } const blob = new Blob([JSON.stringify(STATE, null, 2)], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = "alvessa_state.json"; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1000); });

// No auto-hydrate by default — uncomment to enable if desired
// (async function hydrateOnLoad(){ const st = await fetchState(); if (st && Object.keys(st).length){ STATE = st; refresh(); } })();
</script>
</body>
</html>
