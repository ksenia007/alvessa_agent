<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="/favicon.ico?v=9">
<link rel="icon" type="image/png" sizes="32x32" href="/images/rocket_favicon_32.png?v=9">
<link rel="icon" type="image/png" sizes="64x64" href="/images/rocket_favicon_64.png?v=9">
<link rel="apple-touch-icon" sizes="180x180" href="/images/rocket_favicon_180.png?v=9">
<meta name="theme-color" content="#0b1020">

<title>Alvessa: Gene-Centric Agentic Framework</title>
<style>
  :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  body { margin: 0; background: #0b1020; color: #e6e8ef; }
  .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
  .grid { display: grid; gap: 16px; grid-template-columns: 1fr 1fr; }

  .logo-hero { height: 40px; vertical-align: middle; }
.logo-bar  { height: 24px; vertical-align: middle; }

  .card { background: #121832; border: 1px solid #1e2a52; border-radius: 16px; padding: 16px; box-shadow: 0 6px 24px rgba(0,0,0,0.2); }
  .title { font-size: 20px; font-weight: 700; margin: 0 0 8px; }
  .mono  { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .pill  { display: inline-block; padding: 2px 8px; border-radius: 999px; background:#1a2347; border:1px solid #2a3a72; margin:2px 6px 2px 0; font-size:12px; }
  .answer { white-space: pre-wrap; line-height: 1.5; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .muted { color:#aab4d6; font-size: 12px; }
  button { cursor:pointer; background:#1b2450; color:#e6e8ef; border:1px solid #2a3a72; border-radius:10px; padding:8px 12px; }
  input[type="text"] { width:100%; background:#0e1430; color:#e6e8ef; border:1px solid #2a3a72; border-radius:10px; padding:10px; }
  .full { grid-column: 1 / -1; }
  .json pre { overflow:auto; max-height: 340px; }
  .scroll { max-height: 230px; overflow: auto; }

  /* Centered start screen */
  #hero { min-height: 60vh; display: grid; place-items: center; }
  #hero .card { width: 100%; max-width: 720px; text-align: center; }
  #hero .title { font-size: 24px; margin-bottom: 12px; }

  /* Hide containers until needed */
  #grid { display: none; }
  #runStatusCard { display: none; }
  #toolbar { display: none; } /* appears after first run */

  /* Spinner + status line */
  .spinner { width:16px; height:16px; border:2px solid #2a3a72; border-top-color: transparent; border-radius:50%;
             animation: spin 1s linear infinite; display:inline-block; vertical-align:middle; margin-right:6px; }
  .spinner.big { width:28px; height:28px; border-width:3px; margin-right:8px; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .statusline{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#aab4d6; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:72ch; }

  /* GENCODE histogram */
  .hist-svg { width:100%; height:150px; display:block; }
  .hist-axis { font-size:12px; fill:#aab4d6; }
  .hist-bar { fill:#2a3a72; }
  .hist-bar:hover { opacity:0.9; }
  .hist-baseline { stroke:#2a3a72; stroke-width:1; }

  /* GWAS UI helpers */
.gwas-head { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
.gwas-tabs { display:flex; gap:6px; }
.gwas-tabs button { padding:6px 10px; border-radius:999px; background:#0e1430; border:1px solid #2a3a72; color:#e6e8ef; cursor:pointer; font-size:12px; }
.gwas-tabs button.active { background:#1a2347; }
.gwas-grid { display:grid; gap:12px; grid-template-columns: 1fr; }
@media (min-width: 900px){ .gwas-grid { grid-template-columns: 1fr 1fr; } }
.gwas-list { max-height: 240px; overflow:auto; padding-right:4px; }
.pill.clickable { cursor:pointer; }
.gwas-detail { border:1px solid #2a3a72; border-radius:12px; padding:10px; background:#0e1430; min-height: 88px; }
.gwas-table { width:100%; border-collapse:collapse; font-size:12px; }
.gwas-table th, .gwas-table td { padding:6px 8px; border-bottom:1px solid #1e2a52; text-align:left; }
.gwas-meta { color:#aab4d6; font-size:12px; }

/* Variant Summary table */
.vs-table { width: 100%; border-collapse: collapse; }
.vs-table th, .vs-table td {
  border-bottom: 1px solid #2a3a72;
  padding: 6px 8px;
  text-align: left;
  vertical-align: top;
}
.vs-table thead th { position: sticky; top: 0; background: #121832; }

  
</style>
<body>
<div class="wrap">

  <!-- Centered start screen -->
  <div id="hero">
    <div class="card">
        <div class="title">
            <img src="/images/rocket_logo.png" alt="Alvessa logo" class="logo-hero" />
            <span style="margin-left:8px;">Alvessa: Gene-Centric Agentic Framework</span>
          </div>
      <div class="muted" style="margin-bottom:12px;">Enter a question to explore entities, tools, and curated outputs.</div>
      <div class="row" style="justify-content:center;">
        <input id="q" type="text" placeholder="Ask a question… e.g., Genes interacting with TP53" />
        <button id="runBtn" onclick="run()">Run</button>
      </div>
      <div class="muted" style="margin-top:8px;">Tip: press Enter to run</div>
    </div>
  </div>

  <!-- Run status (spinner + single last-line status). Stays outside the grid. -->
  <div id="runStatusCard" class="card full">
    <div class="row" style="justify-content:flex-start; gap:12px;">
      <span class="spinner big"></span>
      <div>
        <div style="font-weight:600;">Running…</div>
        <div id="statusLine" class="statusline" title="latest log line">(waiting for output…)</div>
      </div>
    </div>
  </div>

  <!-- Secondary input toolbar (shown after first run so you can ask more) -->
  <div id="toolbar" class="card full">
    <div class="row" style="justify-content:space-between; gap:12px;">
      <div class="muted" style="min-width:160px;">Ask another question</div>
      <div class="row" style="flex:1;">
        <input id="q2" type="text" placeholder="Type another question… then press Enter" />
        <button onclick="runFrom('q2')">Run</button>
      </div>
    </div>
  </div>

  <!-- Main content grid -->
  <div id="grid" class="grid">

    <div id="brandCard" class="card full">
        <div class="row" style="align-items:center; gap:12px;">
          <img src="/images/rocket_logo.png" alt="Alvessa logo" class="logo-bar" />
          <div class="title" style="margin:0;">Alvessa: Gene-Centric Agentic Framework</div>
        </div>
      </div>

    <div class="card full">
      <div class="title" id="questionTitle">Question</div>
      <div id="question" style="font-size:18px; font-weight:600;"></div>
    </div>

    <div id="entitiesCard" class="card" data-section style="display:none;">
      <div class="title">Detected Entities</div>
      <div id="entities"></div>
    </div>

    <div id="toolsCard" class="card" data-section style="display:none;">
      <div class="title">Tools Used</div>
      <div id="tools" class="row"></div>
    </div>

    <div id="answerCard" class="card" data-section style="display:none;">
      <div class="title">Answer</div>
      <div id="answer" class="answer"></div>
    </div>

    <div id="evidenceCard" class="card full" data-section style="display:none;">
      <div class="title">Evidence</div>
      <div id="evidence"></div>
    </div>

    <div id="biogridCard" class="card" data-section style="display:none;">
      <div class="title">BioGRID (genes)</div>
      <div id="biogrid"></div>
    </div>

    <div id="reactomeCard" class="card" data-section style="display:none;">
      <div class="title">Reactome Pathways</div>
      <div id="reactome" class="scroll"></div>
    </div>

    <div id="uniprotCard" class="card full" data-section style="display:none;">
      <div class="title">UniProt (base)</div>
      <div id="uniprot"></div>
    </div>

    <div id="gwasCard" class="card full" data-section style="display:none;">
      <div class="title">GWAS Summary</div>
      <div id="gwas"></div>
    </div>

    <div id="gencodeCard" class="card full" data-section style="display:none;">
      <div class="title">GENCODE (per gene)</div>
      <div id="gencode"></div>
    </div>

    <div id="variantSummaryCard" class="card full" data-section style="display:none;">
      <div class="title">Variant Summary</div>
      <div id="variantSummary"></div>
    </div>

    <div id="debugCard" class="card full" data-section style="display:none;">
      <div class="title">Debug (other fields)</div>
      <pre id="debug" class="mono json scroll"></pre>
    </div>

    <div id="rawCard" class="card full json" data-section style="display:none;">
      <div class="title">Raw State (debug)</div>
      <pre id="raw" class="mono"></pre>
    </div>
  </div>
</div>

<script>
  // Basic helpers
  const show  = id => { const el=document.getElementById(id); if (el) el.style.display='block'; };
  const hide  = id => { const el=document.getElementById(id); if (el) el.style.display='none'; };
  const setText = (id, text) => { const el=document.getElementById(id); if (el) el.textContent = text ?? ""; };
  const setHTML = (id, html) => { const el=document.getElementById(id); if (el) el.innerHTML = html ?? ""; };
  const uc = s => (s||"").toUpperCase();
  function escapeHtml(s){ return (s??"").toString().replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;","&gt;":">","\"":"&quot;","'":"&#39;"}[m])); }
  function asPills(arr){ return (arr||[]).map(x=>`<span class="pill">${escapeHtml(x)}</span>`).join(""); }
  function hideAllSections(){ document.querySelectorAll('[data-section]').forEach(el => el.style.display='none'); }
  function setStatus(text){ const el=document.getElementById('statusLine'); if (el){ el.textContent = text || ""; el.title = text || ""; } }

  // Log polling (latest line only)
  let logPos = 0, isPolling = false;
  function showRunStatus(){ show('runStatusCard'); }
  function hideRunStatus(){ hide('runStatusCard'); }

  async function startLogPolling(){
    if (isPolling) return;
    isPolling = true; logPos = 0;
    setStatus("(waiting for output…)"); showRunStatus();
    while (isPolling){
      try{
        const res = await fetch(`/log?pos=${logPos}`, { cache: "no-store" });
        if (!res.ok) throw new Error(String(res.status));
        const { pos, data } = await res.json();
        if (typeof pos === "number") logPos = pos;
        if (data && data.length){
          const lines = data.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
          if (lines.length) setStatus(lines[lines.length - 1]);
        }
      }catch(e){ console.error("[log poll]", e); }
      await new Promise(r => setTimeout(r, 400));
    }
  }
  function stopLogPolling(){ isPolling = false; }

  // Data fetch
  async function fetchState() {
    const res = await fetch("/state");
    if (!res.ok) return null;
    return await res.json();
  }

  // Renderers
  function renderQuestion(st, qInput){
    const q = (qInput && qInput.trim()) || (st?.messages?.slice(-1)[0]?.content) || "";
    setText("question", q);
    setText("questionTitle", "Question");
  }

  function renderEntities(st){
    const genes = st?.genes || [];
    if (genes.length) { setHTML("entities", `<div><strong>Genes:</strong> ${asPills(genes)}</div>`); show("entitiesCard"); }
    else hide("entitiesCard");
  }

  function renderTools(st){
    const used = st?.used_tools || [];
    if (used.length) { setHTML("tools", asPills(used)); show("toolsCard"); }
    else hide("toolsCard");
  }

  function renderAnswer(st){
    const lj = st?.llm_json || {};
    const ans = lj?.answer || "";
    if (ans) { setText("answer", ans); show("answerCard"); }
    else hide("answerCard");

    const ev = Array.isArray(lj?.evidence) ? lj.evidence : [];
    if (ev.length) { setHTML("evidence", ev.map(e=>`<div class="pill">${escapeHtml(e)}</div>`).join("")); show("evidenceCard"); }
    else hide("evidenceCard");
  }
  function renderBioGRID(st){
    const bg = st?.biogrid_predictions;
    if (!bg || typeof bg !== 'object') return hide("biogridCard");
  
    const entries = Object.entries(bg);
    if (!entries.length) {
      setHTML("biogrid", `<div class="muted">no interactions returned</div>`);
      return show("biogridCard");
    }
  
    const html = entries.map(([gene, arr]) => {
      const list = Array.isArray(arr) ? [...new Set(arr)].filter(Boolean) : [];
      const n = list.length;
      if (!n) {
        return `<div style="margin-bottom:10px;">
          <strong>${escapeHtml(uc(gene))}:</strong> 0 genes
          <div class="muted">no interactions returned</div>
        </div>`;
      }
      return `<div style="margin-bottom:10px;">
        <strong>${escapeHtml(uc(gene))}:</strong> ${n} gene${n===1?'':'s'}
        <div class="scroll" style="margin-top:6px;">${asPills(list)}</div>
      </div>`;
    }).join("");
  
    setHTML("biogrid", html);
    show("biogridCard");
  }

  function renderReactome(st){
    const rx = st?.reactome_pathways;
    if (!rx || typeof rx !== 'object') return hide("reactomeCard");
    const rows = Object.entries(rx)
      .filter(([_, paths]) => Array.isArray(paths) && paths.length)
      .map(([gene, paths]) => `<div><strong>${escapeHtml(uc(gene))}</strong><div class="muted">${paths.length} pathways</div><div class="scroll">${asPills(paths.slice(0,50))}</div></div>`)
      .join("");
    if (rows) { setHTML("reactome", rows); show("reactomeCard"); } else hide("reactomeCard");
  }

  function renderUniProtBase(st){
    const up = st?.uniprot_entries_base;
    if (!up || typeof up !== 'object') return hide("uniprotCard");
    const blocks = Object.entries(up).map(([gene, obj])=>{
      if (!obj || typeof obj !== 'object') return "";
      const diseases = obj.diseases || "";
      const func = obj.function || "";
      if (!diseases && !func) return "";
      return `<div style="margin-bottom:12px;">
        <div><strong>${escapeHtml(uc(gene))}</strong></div>
        ${diseases ? `<div class="muted" style="margin-top:4px;">Diseases</div><div class="scroll mono">${escapeHtml(diseases)}</div>` : ""}
        ${func ? `<div class="muted" style="margin-top:6px;">Function</div><div class="scroll mono">${escapeHtml(func)}</div>` : ""}
      </div>`;
    }).join("");
    if (blocks.trim()) { setHTML("uniprot", blocks); show("uniprotCard"); } else hide("uniprotCard");
  }

  <!-- ---------------- GWAS interactive renderer (drop-in) ---------------- -->
  const GWAS = {
    state: {},
  
    // Merge all variant_annotations dictionaries found anywhere in the object.
    collectVariantAnnotations(root){
      const out = {};
      const seen = new Set();
      function mergeOne(dict){
        for (const [vid, v] of Object.entries(dict)){
          if (!out[vid]) { out[vid] = { ...(v||{}) }; }
          else {
            // shallow merge, prefer non-null/new values
            for (const [k, val] of Object.entries(v||{})){
              if (out[vid][k] == null && val != null) out[vid][k] = val;
            }
          }
        }
      }
      function walk(x){
        if (!x || typeof x !== "object") return;
        if (seen.has(x)) return;
        seen.add(x);
        if (x.variant_annotations && typeof x.variant_annotations === "object" && !Array.isArray(x.variant_annotations)){
          mergeOne(x.variant_annotations);
        }
        for (const v of Object.values(x)) walk(v);
      }
      walk(root);
      return out;
    },
  
    deepCollectStringArray(obj, keyNames){
      const out = [];
      const seenVals = new Set();
      const seenObjs = new Set();
      function walk(x){
        if (!x || typeof x !== "object") return;
        if (seenObjs.has(x)) return;
        seenObjs.add(x);
        for (const [k, v] of Object.entries(x)){
          if (keyNames.includes(k) && Array.isArray(v)){
            for (const item of v){
              if (typeof item === "string" && !seenVals.has(item)) {
                seenVals.add(item);
                out.push(item);
              }
            }
          }
          if (v && typeof v === "object") walk(v);
        }
      }
      walk(obj);
      return out;
    },
  
    extractVariantTraits(v){
      const out = new Set();
      const pushOne = s => { if (s && typeof s === "string") out.add(s); };
      const pushMany = a => { if (Array.isArray(a)) a.forEach(pushOne); };
  
      if (Array.isArray(v?.disease_trait)) pushMany(v.disease_trait); else pushOne(v?.disease_trait);
      if (Array.isArray(v?.traits)) pushMany(v.traits); else pushOne(v?.trait);
      if (Array.isArray(v?.phenotypes)) pushMany(v.phenotypes); else pushOne(v?.phenotype);
      if (Array.isArray(v?.mapped_traits)) pushMany(v.mapped_traits); else pushOne(v?.mapped_trait);
      if (Array.isArray(v?.gwas_disease_traits)) pushMany(v.gwas_disease_traits);
  
      return Array.from(out);
    },
  
    extractContext(v){
      return v?.context || v?.variant_category || v?.functional_annotation || v?.consequence || "";
    },
  
    extractP(v){
      const raw = (v?.p_value ?? v?.p ?? null);
      if (typeof raw === "number") return raw;
      if (raw == null) return null;
      const p = parseFloat(String(raw));
      return Number.isFinite(p) ? p : null;
    },
  
    extractORBeta(v){
      const cand = v?.or_beta ?? v?.OR ?? v?.or ?? v?.beta ?? null;
      return (typeof cand === "number") ? cand : null;
    },
  
    normalizeGeneData(obj){
      // 1) merge all annotations everywhere
      const ann = this.collectVariantAnnotations(obj);
  
      // 2) possible fallback IDs
      const fallbackIDs = this.deepCollectStringArray(obj, ["high_risk_snps","gwas_high_risk_snps","snps"]);
  
      // 3) build variants
      const byId = {};
      const variants = Object.entries(ann).map(([vid, v])=>{
        const row = {
          id: vid,
          p_value: this.extractP(v),
          context: this.extractContext(v),
          or_beta: this.extractORBeta(v),
          traits: this.extractVariantTraits(v),
        };
        byId[vid] = row;
        return row;
      });
  
      // 4) add fallback-only ids if needed
      for (const vid of fallbackIDs){
        if (vid && !byId[vid]) {
          byId[vid] = { id: vid, p_value: null, context: "", or_beta: null, traits: [] };
          variants.push(byId[vid]);
        }
      }
  
      // 5) trait universe: start with traits that actually map to variants
      const traitSet = new Set();
      variants.forEach(v => (v.traits||[]).forEach(t => t && traitSet.add(t)));
  
      // Optionally include other summary trait lists (will appear even if unmapped)
      const extraTraits = this.deepCollectStringArray(obj, [
        "disease_traits","gwas_disease_traits","traits","mapped_traits","phenotypes"
      ]);
      for (const t of extraTraits) traitSet.add(t);
  
      const traits = Array.from(traitSet).sort((a,b)=>a.localeCompare(b));
  
      // 6) maps
      const mapT2V = {};
      const mapV2T = {};
      for (const v of variants){
        const tlist = (v.traits||[]);
        mapV2T[v.id] = tlist.slice().sort((a,b)=>a.localeCompare(b));
        for (const t of tlist) {
          if (!t) continue;
          (mapT2V[t] ||= []).push(v.id);
        }
      }
      for (const t in mapT2V){
        mapT2V[t].sort((a,b)=>{
          const va = byId[a], vb = byId[b];
          const pa = (va?.p_value ?? Number.POSITIVE_INFINITY);
          const pb = (vb?.p_value ?? Number.POSITIVE_INFINITY);
          return pa - pb;
        });
      }
  
      return { traits, variants, mapT2V, mapV2T };
    },
  
    ensureStateForGene(safeId, obj, rawKey){
      if (!this.state[safeId]){
        const data = this.normalizeGeneData(obj);
        this.state[safeId] = {
          rawKey,
          mode: "traits",
          selectedTrait: data.traits.find(t => (data.mapT2V[t]||[]).length) || data.traits[0] || null,
          selectedVariant: data.variants
            .slice()
            .sort((a,b)=>(a.p_value??1e300)-(b.p_value??1e300))[0]?.id || null,
          data
        };
      }
      return this.state[safeId];
    },
  
    setMode(id, mode){ const s=this.state[id]; if(!s) return; s.mode=mode; this.renderGene(id); },
    selectTrait(id, trait){ const s=this.state[id]; if(!s) return; s.selectedTrait=trait; s.mode="traits"; this.renderGene(id); },
    selectVariant(id, varId){ const s=this.state[id]; if(!s) return; s.selectedVariant=varId; s.mode="variants"; this.renderGene(id); },
  
    fmtP(p){
      if (p == null || !isFinite(p)) return "NA";
      if (p === 0) return "<1e-300";
      return (p < 1e-3) ? p.toExponential(2) : p.toFixed(3);
    },
  
    geneCounts(obj, data){
      const nVars = data.variants.length;
      const nTraits = data.traits.length;
      const total   = obj?.total_associations ?? nVars;
      const signif  = obj?.total_significant_associations ?? null;
      const studies = obj?.total_studies_analyzed ?? null;
      const bits = [
        `${nTraits} trait${nTraits===1?"":"s"}`,
        `${nVars} variant${nVars===1?"":"s"}`
      ];
      if (Number.isFinite(total))   bits.push(`total: ${total}`);
      if (Number.isFinite(signif))  bits.push(`significant: ${signif}`);
      if (Number.isFinite(studies)) bits.push(`studies: ${studies}`);
      return bits.join(" • ");
    },
  
    renderGene(id){
      const mount = document.getElementById(`gwas-${id}`);
      const s = this.state[id];
      if (!mount || !s) return;
  
      const displayGene = s.rawKey;
      const { data, mode } = s;
  
      const tabs = `
        <div class="gwas-tabs">
          <button class="${mode==='traits'?'active':''}" onclick="GWAS.setMode('${id}','traits')">Traits</button>
          <button class="${mode==='variants'?'active':''}" onclick="GWAS.setMode('${id}','variants')">Variants</button>
        </div>`;
  
      // Left column
      let listHTML = "";
      if (mode === "traits"){
        const pills = data.traits.map(t => {
          const js = String(t).replace(/\\/g,"\\\\").replace(/'/g,"\\'");
          const cls = (s.selectedTrait===t) ? "pill clickable selected" : "pill clickable";
          return `<span class="${cls}" onclick="GWAS.selectTrait('${id}','${js}')">${escapeHtml(t)}</span>`;
        }).join("");
        listHTML = `<div class="gwas-list">${pills || '<div class="muted">No traits found.</div>'}</div>`;
      } else {
        const rows = data.variants
          .slice()
          .sort((a,b)=> (a.p_value??1e300)-(b.p_value??1e300))
          .map(v => `
            <tr class="clickable" onclick="GWAS.selectVariant('${id}','${v.id}')">
              <td class="mono">${escapeHtml(v.id)}</td>
              <td>${escapeHtml(v.context||"")}</td>
              <td class="mono">${this.fmtP(v.p_value)}</td>
              <td class="gwas-meta">${(v.traits||[]).length}</td>
            </tr>`).join("");
        listHTML = rows
          ? `<div class="gwas-list">
               <table class="gwas-table">
                 <thead><tr><th>Variant</th><th>Context</th><th>P</th><th>#traits</th></tr></thead>
                 <tbody>${rows}</tbody>
               </table>
             </div>`
          : '<div class="muted">No variants found.</div>';
      }
  
      // Right column
      let detailHTML = "";
      if (mode === "traits"){
        const t = s.selectedTrait;
        if (!t){
          detailHTML = '<div class="muted">Select a trait to see associated variants.</div>';
        } else {
          const vIds = s.data.mapT2V[t] || [];
          if (!vIds.length){
            detailHTML = `<div><strong>${escapeHtml(t)}</strong><div class="muted">No variants mapped to this trait.</div></div>`;
          } else {
            const rows = vIds.map(vid => {
              const v = s.data.variants.find(x=>x.id===vid);
              return `<tr>
                <td class="mono">${escapeHtml(vid)}</td>
                <td>${escapeHtml(v?.context||"")}</td>
                <td class="mono">${this.fmtP(v?.p_value)}</td>
              </tr>`;
            }).join("");
            detailHTML = `
              <div><strong>${escapeHtml(t)}</strong></div>
              <div class="muted" style="margin:4px 0 8px;">${vIds.length} variant${vIds.length===1?'':'s'}</div>
              <div class="gwas-detail">
                <table class="gwas-table">
                  <thead><tr><th>Variant</th><th>Context</th><th>P</th></tr></thead>
                  <tbody>${rows}</tbody>
                </table>
              </div>`;
          }
        }
      } else {
        const varId = s.selectedVariant;
        if (!varId){
          detailHTML = '<div class="muted">Select a variant to see associated traits.</div>';
        } else {
          const v = s.data.variants.find(x=>x.id===varId);
          const traits = s.data.mapV2T[varId] || [];
          const traitPills = traits.map(t => `<span class="pill">${escapeHtml(t)}</span>`).join("");
          detailHTML = `
            <div><strong>${escapeHtml(varId)}</strong></div>
            <div class="gwas-meta">context: ${escapeHtml(v?.context||"")} • p: <span class="mono">${this.fmtP(v?.p_value)}</span>${(v?.or_beta!=null?` • OR/Beta: ${v.or_beta}`:"")}</div>
            <div class="gwas-detail" style="margin-top:8px;">
              <div class="muted" style="margin-bottom:6px;">Traits</div>
              ${traitPills || '<div class="muted">No traits available.</div>'}
            </div>`;
        }
      }
  
      const counts = this.geneCounts(window.__GWAS_RAW?.[s.rawKey] || {}, s.data);
      mount.innerHTML = `
        <div class="gwas-head">
          <div>
            <div><strong>${escapeHtml(uc(displayGene))}</strong></div>
            <div class="gwas-meta">${counts}</div>
          </div>
          ${tabs}
        </div>
        <div class="gwas-grid" style="margin-top:8px;">
          <div>${listHTML}</div>
          <div>${detailHTML}</div>
        </div>`;
    }
  };
  
  function renderGWAS(st){
    const gw = st?.gwas_associations;
    if (!gw || typeof gw !== 'object') return hide("gwasCard");
    window.__GWAS_RAW = gw;
  
    const html = Object.keys(gw).map(gene => {
      const safe = gene.replace(/[^a-z0-9_-]/gi, '_');
      return `<div id="gwas-${safe}" style="margin-bottom:16px;"></div>`;
    }).join("");
    if (!html.trim()){ hide("gwasCard"); return; }
  
    setHTML("gwas", html);
    show("gwasCard");
  
    for (const [rawGene, obj] of Object.entries(gw)){
      const safe = rawGene.replace(/[^a-z0-9_-]/gi, '_');
      GWAS.ensureStateForGene(safe, obj, rawGene);
      GWAS.renderGene(safe);
    }
  }
  

  function renderGENCODE(st){
    const gc = st?.gene_level_gencode;
    if (!gc || typeof gc !== 'object') return hide("gencodeCard");

    const W = 700, H = 150;
    const P = { top: 10, right: 10, bottom: 40, left: 28 };

    const sections = Object.entries(gc).map(([gene, obj])=>{
      if (!obj || typeof obj !== 'object') return "";

      const exonsMap = obj.exons_per_transcript || {};
      const counts = Object.values(exonsMap).map(v=>Number(v)).filter(n=>Number.isFinite(n));
      const nTx = Array.isArray(obj.transcript_ids) ? obj.transcript_ids.length : (obj.n_transcripts ?? counts.length);

      const spanMin = obj.min_transcript_span_bp, spanMax = obj.max_transcript_span_bp;
      const spanLine = (spanMin && spanMax) ? `<div class="muted">span: ${escapeHtml(spanMin)}–${escapeHtml(spanMax)} bp</div>` : "";

      if (!counts.length){
        return `<div style="margin-bottom:14px;">
          <div><strong>${escapeHtml(uc(gene))}</strong></div>
          <div class="muted">transcripts: ${nTx}</div>
          ${spanLine}
          <div class="muted">No exon data available to plot.</div>
        </div>`;
      }

      const freq = {};
      for (const n of counts) freq[n] = (freq[n]||0) + 1;
      const bins = Object.keys(freq).map(Number).sort((a,b)=>a-b);
      const maxCount = Math.max(...bins.map(b => freq[b]));

      const sorted = [...counts].sort((a,b)=>a-b);
      const mid = Math.floor(sorted.length/2);
      const median = (sorted.length % 2) ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;

      const plotW = W - P.left - P.right;
      const plotH = H - P.top - P.bottom;
      const bandW = plotW / bins.length;
      const gap = Math.min(6, Math.max(2, bandW * 0.12));

      const bars = bins.map((b, i) => {
        const c = freq[b];
        const h = (c / maxCount) * plotH;
        const x = P.left + i * bandW + gap/2;
        const y = P.top + (plotH - h);
        const w = Math.max(1, bandW - gap);
        return `<rect class="hist-bar" x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${w.toFixed(2)}" height="${Math.max(0,h).toFixed(2)}">
                  <title>${b} exons • ${c} transcript${c===1?"":"s"}</title>
                </rect>`;
      }).join("");

      const tickY = H - 18;
      let xLabels = "";
      if (bins.length <= 18) {
        xLabels = bins.map((b, i) => {
          const x = P.left + i * bandW + bandW/2;
          return `<text class="hist-axis" x="${x.toFixed(2)}" y="${tickY}" text-anchor="middle">${b}</text>`;
        }).join("");
      } else {
        const minB = bins[0], maxB = bins[bins.length-1];
        const nearestIdx = Math.max(0, Math.min(bins.length-1, bins.findIndex(v => v>=median)));
        const xMin = P.left + 0 * bandW + bandW/2;
        const xMed = P.left + nearestIdx * bandW + bandW/2;
        const xMax = P.left + (bins.length-1) * bandW + bandW/2;
        xLabels = `
          <text class="hist-axis" x="${xMin.toFixed(2)}" y="${tickY}" text-anchor="middle">${minB}</text>
          <text class="hist-axis" x="${xMed.toFixed(2)}" y="${tickY}" text-anchor="middle">median ${median}</text>
          <text class="hist-axis" x="${xMax.toFixed(2)}" y="${tickY}" text-anchor="middle">${maxB}</text>
        `;
      }

      const baseY = P.top + plotH;
      const baseline = `<line class="hist-baseline" x1="${P.left}" y1="${baseY}" x2="${W-P.right}" y2="${baseY}"/>`;
      const xTitle = `<text class="hist-axis" x="${W/2}" y="${H-4}" text-anchor="middle"># exons</text>`;
      const yTitle = `<text class="hist-axis" transform="rotate(-90 12 ${H/2})" x="12" y="${H/2}" text-anchor="middle"># transcripts</text>`;

      return `<div style="margin-bottom:16px;">
        <div><strong>${escapeHtml(uc(gene))}</strong></div>
        <div class="muted">transcripts: ${nTx} • median exons: ${median}</div>
        ${spanLine}
        <svg class="hist-svg" viewBox="0 0 ${W} ${H}">
          ${yTitle}
          ${baseline}
          ${bars}
          ${xLabels}
          ${xTitle}
        </svg>
      </div>`;
    }).join("");

    if (sections.trim()) { setHTML("gencode", sections); show("gencodeCard"); }
    else hide("gencodeCard");
  }
    // ---------------- Variant Summary renderer ----------------
    function renderVariantSummary(st){
      const sei   = st?.sei_predictions || {};
      const am    = st?.alphamissense_predictions || {};
      const dbsum = st?.dbsnp_summaries || {};     // expects { gene: {... counts and rsid lists ...} }
      const gwas  = st?.gwas_associations || {};
    
      // union of genes that appear in any source
      const genes = new Set([
        ...Object.keys(sei),
        ...Object.keys(am),
        ...Object.keys(dbsum),
        ...Object.keys(gwas)
      ]);
    
      const sections = [];
    
      for (const gene of genes){
        const geneSei = sei[gene] || {};
        const geneAm  = am[gene]  || {};
        const geneDb  = dbsum[gene] || {};
        const gwasObj = gwas[gene];
    
        // collect all variant_annotations for this gene (merges from anywhere in the object)
        const ann = (window.GWAS && typeof GWAS.collectVariantAnnotations === "function")
          ? GWAS.collectVariantAnnotations(gwasObj || {})
          : (function collectAllVariantAnnotations(obj){
              const out = {}; const seen = new Set();
              function walk(x){
                if (!x || typeof x !== "object" || seen.has(x)) return;
                seen.add(x);
                if (x.variant_annotations && typeof x.variant_annotations === "object" && !Array.isArray(x.variant_annotations)){
                  for (const [vid, v] of Object.entries(x.variant_annotations)) out[vid] = v;
                }
                for (const v of Object.values(x)) walk(v);
              }
              walk(gwasObj || {});
              return out;
            })();
    
        // frequency buckets for this gene
        const rareSet       = new Set(geneDb["rare_rsids"] || []);
        const commonSet     = new Set(geneDb["common_rsids"] || []);
        const veryCommonSet = new Set(geneDb["very_common_rsids"] || []);
        const freqLabel = (rs) => (
          rareSet.has(rs)       ? "Rare (<1%)" :
          commonSet.has(rs)     ? "Common (1–15%)" :
          veryCommonSet.has(rs) ? "Very common (>15%)" : "N/A"
        );
    
        // gather all rsids we know about for this gene
        const rsids = new Set([
          ...Object.keys(geneSei),
          ...Object.keys(geneAm),
          ...Object.keys(ann || {}),
          ...(geneDb["rare_rsids"] || []),
          ...(geneDb["common_rsids"] || []),
          ...(geneDb["very_common_rsids"] || [])
        ]);
        if (rsids.size === 0) continue;
    
        // helpers to extract GWAS fields
        const extractP = (v) => {
          const raw = (v?.p_value ?? v?.p ?? null);
          if (typeof raw === "number") return raw;
          if (raw == null) return null;
          const n = parseFloat(String(raw));
          return Number.isFinite(n) ? n : null;
        };
        const extractTraits = (v) => {
          const out = new Set();
          const add = s => { if (s && typeof s === "string") out.add(s); };
          const addMany = a => { if (Array.isArray(a)) a.forEach(add); };
          if (!v) return [];
          addMany(v.disease_trait); add(v.disease_trait);
          addMany(v.traits); add(v.trait);
          addMany(v.phenotypes); add(v.phenotype);
          addMany(v.mapped_traits); add(v.mapped_trait);
          addMany(v.gwas_disease_traits);
          return Array.from(out);
        };
    
        // build rows
        const rows = Array.from(rsids).map(rs => {
          const seiLabel = geneSei?.[rs] ?? "N/A";
          const amMap    = geneAm?.[rs] || null;
          let amList = [];
          if (amMap && typeof amMap === "object"){
            for (const [change, label] of Object.entries(amMap)){
              // "SNP:C->A" -> "C→A" then append label if present
              const c = change.replace(/^SNP:/i, "").replace("->", "→");
              amList.push(label ? `${c}: ${label}` : c);
            }
          }
          if (amList.length === 0) amList = ["N/A"];
    
          const vAnn = ann?.[rs] || {};
          const traits = extractTraits(vAnn);
          const p = extractP(vAnn); // used for sorting only
    
          return {
            rs,
            freq: freqLabel(rs),
            sei: seiLabel || "N/A",
            am: amList,
            traits,
            p
          };
        });
    
        // sort by frequency bucket, then by p-value asc, then by rsid
        const freqOrder = {"Rare (<1%)":0, "Common (1–15%)":1, "Very common (>15%)":2, "N/A":3};
        rows.sort((a,b)=>{
          const fa = (freqOrder[a.freq] ?? 9), fb = (freqOrder[b.freq] ?? 9);
          if (fa !== fb) return fa - fb;
          const pa = (a.p ?? Number.POSITIVE_INFINITY), pb = (b.p ?? Number.POSITIVE_INFINITY);
          if (pa !== pb) return pa - pb;
          return a.rs.localeCompare(b.rs);
        });
    
        // counts line above the table
        const statsBits = [];
        if (Number.isFinite(geneDb["num_rare_variants (<1%)"]))       statsBits.push(`rare: ${geneDb["num_rare_variants (<1%)"]}`);
        if (Number.isFinite(geneDb["num_common_variants (1-15%)"]))   statsBits.push(`common: ${geneDb["num_common_variants (1-15%)"]}`);
        if (Number.isFinite(geneDb["num_very_common_variants (>15%)"])) statsBits.push(`very common: ${geneDb["num_very_common_variants (>15%)"]}`);
    
        const rowsHtml = rows.map(r=>{
          const amHtml = r.am.map(x=>`<span class="pill">${escapeHtml(x)}</span>`).join(" ");
          const tShown = r.traits.slice(0, 6);
          const tMore  = r.traits.length > 6 ? `<span class="muted"> +${r.traits.length-6} more</span>` : "";
          const traitsHtml = tShown.map(t=>`<span class="pill">${escapeHtml(t)}</span>`).join(" ") + tMore;
          return `<tr>
            <td class="mono">${escapeHtml(r.rs)}</td>
            <td>${escapeHtml(r.freq)}</td>
            <td>${escapeHtml(r.sei)}</td>
            <td>${amHtml || 'N/A'}</td>
            <td>${traitsHtml || '<span class="muted">N/A</span>'}</td>
          </tr>`;
        }).join("");
    
        sections.push(`
          <div style="margin-bottom:8px;">
            <strong>${escapeHtml(uc(gene))}</strong>
            ${statsBits.length ? `<span class="muted"> • ${statsBits.join(" • ")}</span>` : ""}
          </div>
          <div class="scroll">
            <table class="vs-table">
              <thead>
                <tr><th>Variant</th><th>Frequency</th><th>SEI label</th><th>AlphaMissense</th><th>GWAS traits</th></tr>
              </thead>
              <tbody>${rowsHtml}</tbody>
            </table>
          </div>
        `);
      }
    
      if (sections.length){
        setHTML("variantSummary", sections.join(""));
        show("variantSummaryCard");
      } else {
        hide("variantSummaryCard");
      }
    }
    


  function renderDebug(st){
    const keys = [
      "uniprot_entries_gwas",
      "gene_disease_traits",
      "gene_function_traits",
      "gene_GO_traits",
      "humanbase_predictions",
      "humanbase_expecto",
      "tissue_expression_preds_variant_text_description",
      "dbsnp_variants",
      "sei_predictions",
      "alphamissense_predictions",
      "biogrid_summarized_go"
    ];
    const subset = {};
    for (const k of keys) {
      const v = st?.[k];
      if (v && ((Array.isArray(v) && v.length) || (typeof v === 'object' && Object.keys(v).length))) {
        subset[k] = v;
      }
    }
    if (Object.keys(subset).length) { setText("debug", JSON.stringify(subset, null, 2)); show("debugCard"); } else hide("debugCard");
  }

  function renderRaw(st){
    if (st) { setText("raw", JSON.stringify(st, null, 2)); show("rawCard"); }
    else hide("rawCard");
  }

  // Orchestration
  async function refresh(qJustRan="") {
    const st = await fetchState();
    if (!st) return;
  
    const hero = document.getElementById('hero');
    if (hero && hero.style.display !== 'none'){ hide('hero'); show('grid'); }
    show('toolbar');
    const q2 = document.getElementById('q2'); if (q2) { q2.value = ""; q2.focus(); }
  
    renderQuestion(st, qJustRan);
    renderEntities(st);
    renderTools(st);
    renderAnswer(st);
    renderBioGRID(st);
    renderReactome(st);
    renderUniProtBase(st);
    renderGWAS(st);
    renderVariantSummary(st);
  
    renderGENCODE(st);
    renderDebug(st);
    renderRaw(st);
  }
  // Run helpers
  async function run(qOverride) {
    const qEl = document.getElementById("q");
    const q = (typeof qOverride === "string" ? qOverride : (qEl?.value || "")).trim();
    if (!q) { alert("Type a question first."); return; }
    if (qEl) qEl.blur();

    // Clear previous sections; keep layout
    hideAllSections();
    setStatus("(waiting for output…)");
    showRunStatus();

    // Start polling logs before kicking off the run
    startLogPolling();

    const res = await fetch("/run?q=" + encodeURIComponent(q));
    if (!res.ok) {
      setStatus("Run failed.");
      setTimeout(()=>{ stopLogPolling(); hideRunStatus(); }, 800);
      return;
    }

    await refresh(q);
    setTimeout(()=>{ stopLogPolling(); hideRunStatus(); }, 800);
  }

  function runFrom(inputId){
    const el = document.getElementById(inputId);
    const val = el ? el.value.trim() : "";
    if (!val) { alert("Type a question first."); return; }
    run(val);
  }

  // Enter-to-run
  window.addEventListener('load', () => {
    const input = document.getElementById('q');
    input?.focus();
    input?.addEventListener('keydown', (e) => { if (e.key === 'Enter') run(); });

    const input2 = document.getElementById('q2');
    input2?.addEventListener('keydown', (e) => { if (e.key === 'Enter') runFrom('q2'); });
  });
</script>
</body>
</html>

