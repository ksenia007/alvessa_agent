<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="/favicon.ico?v=9">
<link rel="icon" type="image/png" sizes="32x32" href="/images/rocket_favicon_32.png?v=9">
<link rel="icon" type="image/png" sizes="64x64" href="/images/rocket_favicon_64.png?v=9">
<link rel="apple-touch-icon" sizes="180x180" href="/images/rocket_favicon_180.png?v=9">
<meta name="theme-color" content="#0b1020">

<title>Alvessa: Gene-Centric Agentic Framework</title>
<style>
  :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  body { margin: 0; background: #0b1020; color: #e6e8ef; }
  .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
  .grid { display: grid; gap: 16px; grid-template-columns: 1fr 1fr; }

  .logo-hero { height: 40px; vertical-align: middle; }
.logo-bar  { height: 24px; vertical-align: middle; }

  .card { background: #121832; border: 1px solid #1e2a52; border-radius: 16px; padding: 16px; box-shadow: 0 6px 24px rgba(0,0,0,0.2); }
  .title { font-size: 20px; font-weight: 700; margin: 0 0 8px; }
  .mono  { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .pill  { display: inline-block; padding: 2px 8px; border-radius: 999px; background:#1a2347; border:1px solid #2a3a72; margin:2px 6px 2px 0; font-size:12px; }
  .answer { white-space: pre-wrap; line-height: 1.5; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .muted { color:#aab4d6; font-size: 12px; }
  button { cursor:pointer; background:#1b2450; color:#e6e8ef; border:1px solid #2a3a72; border-radius:10px; padding:8px 12px; }
  input[type="text"] { width:100%; background:#0e1430; color:#e6e8ef; border:1px solid #2a3a72; border-radius:10px; padding:10px; }
  .full { grid-column: 1 / -1; }
  .json pre { overflow:auto; max-height: 340px; }
  .scroll { max-height: 180px; overflow: auto; }

  /* Centered start screen */
  #hero { min-height: 60vh; display: grid; place-items: center; }
  #hero .card { width: 100%; max-width: 720px; text-align: center; }
  #hero .title { font-size: 24px; margin-bottom: 12px; }

  /* Hide containers until needed */
  #grid { display: none; }
  #runStatusCard { display: none; }
  #toolbar { display: none; } /* appears after first run */

  /* Spinner + status line */
  .spinner { width:16px; height:16px; border:2px solid #2a3a72; border-top-color: transparent; border-radius:50%;
             animation: spin 1s linear infinite; display:inline-block; vertical-align:middle; margin-right:6px; }
  .spinner.big { width:28px; height:28px; border-width:3px; margin-right:8px; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .statusline{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#aab4d6; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:72ch; }


  /* Brand header (results page) */
.brand-header {
  grid-column: 1 / -1;          /* span full grid width */
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 10px 0 6px;
  background: transparent;      /* no card background */
  border: 0;                    /* no border */
  box-shadow: none;             /* no shadow */
}

.logo-brand { height: 44px; }

.brand-title {
  margin: 0;
  font-weight: 800;
  text-align: center;
  font-size: clamp(24px, 3.2vw, 38px);
  letter-spacing: 0.2px;
}

  /* GENCODE histogram */
  .hist-svg { width:100%; height:150px; display:block; }
  .hist-axis { font-size:12px; fill:#aab4d6; }
  .hist-bar { fill:#2a3a72; }
  .hist-bar:hover { opacity:0.9; }
  .hist-baseline { stroke:#2a3a72; stroke-width:1; }

  /* GWAS UI helpers */
.gwas-head { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
.gwas-tabs { display:flex; gap:6px; }
.gwas-tabs button { padding:6px 10px; border-radius:999px; background:#0e1430; border:1px solid #2a3a72; color:#e6e8ef; cursor:pointer; font-size:12px; }
.gwas-tabs button.active { background:#1a2347; }
.gwas-grid { display:grid; gap:12px; grid-template-columns: 1fr; }
@media (min-width: 900px){ .gwas-grid { grid-template-columns: 1fr 1fr; } }
.gwas-list { max-height: 240px; overflow:auto; padding-right:4px; }
.pill.clickable { cursor:pointer; }
.gwas-detail { border:1px solid #2a3a72; border-radius:12px; padding:10px; background:#0e1430; min-height: 88px; }
.gwas-table { width:100%; border-collapse:collapse; font-size:12px; }
.gwas-table th, .gwas-table td { padding:6px 8px; border-bottom:1px solid #1e2a52; text-align:left; }
.gwas-meta { color:#aab4d6; font-size:12px; }


/* Variant Summary: widen + allow horizontal scroll where needed */
.vs-scroll { overflow: auto; }
.vs-table { width: 100%; min-width: 1400px; border-collapse: collapse; }
.vs-table th, .vs-table td { white-space: nowrap; }            /* keep most columns single-line */
.vs-table td.wrap, .vs-table th.wrap { white-space: normal; }  /* but allow wrapping for verbose cells */
.vs-table td.traits { max-width: 520px; }                      /* give traits room */
.vs-table td.expecto { max-width: 560px; }   
.vs-table thead th { position: sticky; top: 0; background: #121832; }
button.mini { cursor:pointer; background:#0e1430; color:#e6e8ef; border:1px solid #2a3a72; border-radius:999px; padding:2px 8px; font-size:11px; margin-left:6px; }
.exp-detail-box { background:#0e1430; border:1px solid #2a3a72; border-radius:10px; padding:8px; }
/* Expecto summary lines */
.expecto-line { display:block; line-height:1.35; margin:2px 0; }
.xnum { font-weight:800; font-size:1.12em; padding:0 6px; border-radius:6px; background:#0e1430; border:1px solid #2a3a72; display:inline-block; }
.xpct { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; opacity:0.9; }
.xtissue { font-weight:600; }
  
.vs-table{
  font-size: 13px;         
  line-height: 1.45;
}
.vs-table th, .vs-table td{
  padding: 8px 12px;        /* more horiz spacing between columns */
}
.vs-table td.traits, .vs-table td.expecto{
  max-width: 620px;         /* a bit wider for wordy cells */
}

</style>
<body>
<div class="wrap">

  <!-- Centered start screen -->
  <div id="hero">
    <div class="card">
        <div class="title">
            <img src="/images/rocket_logo.png" alt="Alvessa logo" class="logo-hero" />
            <span style="margin-left:8px;">Alvessa: Gene-Centric Agentic Framework</span>
          </div>
      <div class="muted" style="margin-bottom:12px;">Enter a question to explore entities, tools, and curated outputs.</div>
      <div class="row" style="justify-content:center;">
        <input id="q" type="text" placeholder="Ask a question… e.g., Genes interacting with TP53" />
        <button id="runBtn" onclick="run()">Run</button>
      </div>
      <div class="muted" style="margin-top:8px;">Tip: press Enter to run</div>
    </div>
  </div>

  <!-- Run status (spinner + single last-line status). Stays outside the grid. -->
  <div id="runStatusCard" class="card full">
    <div class="row" style="justify-content:flex-start; gap:12px;">
      <span class="spinner big"></span>
      <div>
        <div style="font-weight:600;">Running…</div>
        <div id="statusLine" class="statusline" title="latest log line">(waiting for output…)</div>
      </div>
    </div>
  </div>

  <!-- Secondary input toolbar (shown after first run so you can ask more) -->
  <div id="toolbar" class="card full">
    <div class="row" style="justify-content:space-between; gap:12px;">
      <div class="muted" style="min-width:160px;">Ask another question</div>
      <div class="row" style="flex:1;">
        <input id="q2" type="text" placeholder="Type another question… then press Enter" />
        <button onclick="runFrom('q2')">Run</button>
      </div>
    </div>
  </div>

  <!-- Main content grid -->
  <div id="grid" class="grid">

    <div id="brand" class="brand-header">
      <img src="/images/rocket_logo.png" alt="Alvessa logo" class="logo-brand" />
      <h1 class="brand-title">Alvessa: Gene-Centric Agentic Framework</h1>
    </div>

    <div class="card full">
      <div class="title" id="questionTitle">Question</div>
      <div id="question" style="font-size:18px; font-weight:600;"></div>
    </div>

    <div id="entitiesCard" class="card" data-section style="display:none;">
      <div class="title">Detected Entities</div>
      <div id="entities"></div>
    </div>

    <div id="toolsCard" class="card" data-section style="display:none;">
      <div class="title">Tools Used</div>
      <div id="tools" class="row"></div>
    </div>

    <div id="answerCard" class="card" data-section style="display:none;">
      <div class="title">Answer</div>
      <div id="answer" class="answer"></div>
    </div>

    <div id="evidenceCard" class="card full" data-section style="display:none;">
      <div class="title">Evidence</div>
      <div id="evidence"></div>
    </div>

    <div id="biogridCard" class="card" data-section style="display:none;">
      <div class="title">BioGRID (genes)</div>
      <div id="biogrid"></div>
    </div>

    <div id="reactomeCard" class="card" data-section style="display:none;">
      <div class="title">Reactome Pathways</div>
      <div id="reactome" class="scroll"></div>
    </div>

    <div id="uniprotCard" class="card full" data-section style="display:none;">
      <div class="title">UniProt (base)</div>
      <div id="uniprot"></div>
    </div>

    <div id="gwasCard" class="card full" data-section style="display:none;">
      <div class="title">GWAS Summary</div>
      <div id="gwas"></div>
    </div>

    <div id="gencodeCard" class="card full" data-section style="display:none;">
      <div class="title">GENCODE (per gene)</div>
      <div id="gencode"></div>
    </div>

    <div id="variantSummaryCard" class="card full" data-section style="display:none;">
      <div class="title">Variant Summary</div>
      <div id="variantSummary"></div>
    </div>

    <div id="debugCard" class="card full" data-section style="display:none;">
      <div class="title">Debug (other fields)</div>
      <pre id="debug" class="mono json scroll"></pre>
    </div>

    <div id="rawCard" class="card full json" data-section style="display:none;">
      <div class="title">Raw State (debug)</div>
      <pre id="raw" class="mono"></pre>
    </div>
  </div>
</div>

<script>
  // Basic helpers
  const show  = id => { const el=document.getElementById(id); if (el) el.style.display='block'; };
  const hide  = id => { const el=document.getElementById(id); if (el) el.style.display='none'; };
  const setText = (id, text) => { const el=document.getElementById(id); if (el) el.textContent = text ?? ""; };
  const setHTML = (id, html) => { const el=document.getElementById(id); if (el) el.innerHTML = html ?? ""; };
  const uc = s => (s||"").toUpperCase();
  function escapeHtml(s){ return (s??"").toString().replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;","&gt;":">","\"":"&quot;","'":"&#39;"}[m])); }
  function asPills(arr){ return (arr||[]).map(x=>`<span class="pill">${escapeHtml(x)}</span>`).join(""); }
  function hideAllSections(){ document.querySelectorAll('[data-section]').forEach(el => el.style.display='none'); }
  function setStatus(text){ const el=document.getElementById('statusLine'); if (el){ el.textContent = text || ""; el.title = text || ""; } }

  // Log polling (latest line only)
  let logPos = 0, isPolling = false;
  function showRunStatus(){ show('runStatusCard'); }
  function hideRunStatus(){ hide('runStatusCard'); }

  async function startLogPolling(){
    if (isPolling) return;
    isPolling = true; logPos = 0;
    setStatus("(waiting for output…)"); showRunStatus();
    while (isPolling){
      try{
        const res = await fetch(`/log?pos=${logPos}`, { cache: "no-store" });
        if (!res.ok) throw new Error(String(res.status));
        const { pos, data } = await res.json();
        if (typeof pos === "number") logPos = pos;
        if (data && data.length){
          const lines = data.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
          if (lines.length) setStatus(lines[lines.length - 1]);
        }
      }catch(e){ console.error("[log poll]", e); }
      await new Promise(r => setTimeout(r, 400));
    }
  }
  function stopLogPolling(){ isPolling = false; }

  // Data fetch
  async function fetchState() {
    const res = await fetch("/state");
    if (!res.ok) return null;
    return await res.json();
  }

  // Renderers
  function renderQuestion(st, qInput){
    const q = (qInput && qInput.trim()) || (st?.messages?.slice(-1)[0]?.content) || "";
    setText("question", q);
    setText("questionTitle", "Question");
  }

  function renderEntities(st){
    const genes = st?.genes || [];
    if (genes.length) { setHTML("entities", `<div><strong>Genes:</strong> ${asPills(genes)}</div>`); show("entitiesCard"); }
    else hide("entitiesCard");
  }

  function renderTools(st){
    const used = st?.used_tools || [];
    if (used.length) { setHTML("tools", asPills(used)); show("toolsCard"); }
    else hide("toolsCard");
  }

  function renderAnswer(st){
    const lj = st?.llm_json || {};
    const ans = lj?.answer || "";
    if (ans) { setText("answer", ans); show("answerCard"); }
    else hide("answerCard");

    const ev = Array.isArray(lj?.evidence) ? lj.evidence : [];
    if (ev.length) { setHTML("evidence", ev.map(e=>`<div class="pill">${escapeHtml(e)}</div>`).join("")); show("evidenceCard"); }
    else hide("evidenceCard");
  }
  function renderBioGRID(st){
    const bg = st?.biogrid_predictions;
    if (!bg || typeof bg !== 'object') return hide("biogridCard");
  
    const entries = Object.entries(bg);
    if (!entries.length) {
      setHTML("biogrid", `<div class="muted">no interactions returned</div>`);
      return hide("biogridCard");
    }
  
    const html = entries.map(([gene, arr]) => {
      const list = Array.isArray(arr) ? [...new Set(arr)].filter(Boolean) : [];
      const n = list.length;
      if (!n) {
        return `<div style="margin-bottom:10px;">
          <strong>${escapeHtml(uc(gene))}:</strong> 0 genes
          <div class="muted">no interactions returned</div>
        </div>`;
      }
      return `<div style="margin-bottom:10px;">
        <strong>${escapeHtml(uc(gene))}:</strong> ${n} gene${n===1?'':'s'}
        <div class="scroll" style="margin-top:6px;">${asPills(list)}</div>
      </div>`;
    }).join("");
  
    setHTML("biogrid", html);
    show("biogridCard");
  }

  function renderReactome(st){
    const rx = st?.reactome_pathways;
    if (!rx || typeof rx !== 'object') return hide("reactomeCard");
    const rows = Object.entries(rx)
      .filter(([_, paths]) => Array.isArray(paths) && paths.length)
      .map(([gene, paths]) => `<div><strong>${escapeHtml(uc(gene))}</strong><div class="muted">${paths.length} pathways</div><div class="scroll">${asPills(paths.slice(0,50))}</div></div>`)
      .join("");
    if (rows) { setHTML("reactome", rows); show("reactomeCard"); } else hide("reactomeCard");
  }

  function renderUniProtBase(st){
    const up = st?.uniprot_entries_base;
    if (!up || typeof up !== 'object') return hide("uniprotCard");
    const blocks = Object.entries(up).map(([gene, obj])=>{
      if (!obj || typeof obj !== 'object') return "";
      const diseases = obj.diseases || "";
      const func = obj.function || "";
      if (!diseases && !func) return "";
      return `<div style="margin-bottom:12px;">
        <div><strong>${escapeHtml(uc(gene))}</strong></div>
        ${diseases ? `<div class="muted" style="margin-top:4px;">Diseases</div><div class="scroll mono">${escapeHtml(diseases)}</div>` : ""}
        ${func ? `<div class="muted" style="margin-top:6px;">Function</div><div class="scroll mono">${escapeHtml(func)}</div>` : ""}
      </div>`;
    }).join("");
    if (blocks.trim()) { setHTML("uniprot", blocks); show("uniprotCard"); } else hide("uniprotCard");
  }

  <!-- ---------------- GWAS interactive renderer (drop-in) ---------------- -->
  const GWAS = {
    state: {},
  
    // Merge all variant_annotations dictionaries found anywhere in the object.
    collectVariantAnnotations(root){
      const out = {};
      const seen = new Set();
      function mergeOne(dict){
        for (const [vid, v] of Object.entries(dict)){
          if (!out[vid]) { out[vid] = { ...(v||{}) }; }
          else {
            // shallow merge, prefer non-null/new values
            for (const [k, val] of Object.entries(v||{})){
              if (out[vid][k] == null && val != null) out[vid][k] = val;
            }
          }
        }
      }
      function walk(x){
        if (!x || typeof x !== "object") return;
        if (seen.has(x)) return;
        seen.add(x);
        if (x.variant_annotations && typeof x.variant_annotations === "object" && !Array.isArray(x.variant_annotations)){
          mergeOne(x.variant_annotations);
        }
        for (const v of Object.values(x)) walk(v);
      }
      walk(root);
      return out;
    },
  
    deepCollectStringArray(obj, keyNames){
      const out = [];
      const seenVals = new Set();
      const seenObjs = new Set();
      function walk(x){
        if (!x || typeof x !== "object") return;
        if (seenObjs.has(x)) return;
        seenObjs.add(x);
        for (const [k, v] of Object.entries(x)){
          if (keyNames.includes(k) && Array.isArray(v)){
            for (const item of v){
              if (typeof item === "string" && !seenVals.has(item)) {
                seenVals.add(item);
                out.push(item);
              }
            }
          }
          if (v && typeof v === "object") walk(v);
        }
      }
      walk(obj);
      return out;
    },
  
    extractVariantTraits(v){
      const out = new Set();
      const pushOne = s => { if (s && typeof s === "string") out.add(s); };
      const pushMany = a => { if (Array.isArray(a)) a.forEach(pushOne); };
  
      // Handle new nested format: associated_disease_trait: { trait_name: { p_value, risk_score } }
      if (v?.associated_disease_trait && typeof v.associated_disease_trait === "object") {
        Object.keys(v.associated_disease_trait).forEach(pushOne);
      }
      
      // Handle legacy formats for compatibility
      if (Array.isArray(v?.disease_trait)) pushMany(v.disease_trait); else pushOne(v?.disease_trait);
      if (Array.isArray(v?.traits)) pushMany(v.traits); else pushOne(v?.trait);
      if (Array.isArray(v?.phenotypes)) pushMany(v.phenotypes); else pushOne(v?.phenotype);
      if (Array.isArray(v?.mapped_traits)) pushMany(v.mapped_traits); else pushOne(v?.mapped_trait);
      if (Array.isArray(v?.gwas_disease_traits)) pushMany(v.gwas_disease_traits);
  
      return Array.from(out);
    },
  
    extractContext(v){
      // Try to get context from coordinates if available
      if (v?.coordinates && Array.isArray(v.coordinates) && v.coordinates.length > 0) {
        const coord = v.coordinates[0];
        return coord?.context || coord?.region || "";
      }
      return v?.context || v?.variant_category || v?.functional_annotation || v?.consequence || "";
    },
  
    extractP(v){
      // First check direct p_value (legacy format)
      let raw = (v?.p_value ?? v?.p ?? null);
      
      // If not found, check the new nested format: associated_disease_trait: { trait_name: { p_value, risk_score } }
      if (raw == null && v?.associated_disease_trait && typeof v.associated_disease_trait === "object") {
        // Get the best (lowest) p_value from all disease traits
        let bestP = null;
        for (const traitData of Object.values(v.associated_disease_trait)) {
          if (traitData?.p_value != null) {
            const p = traitData.p_value;
            if (bestP == null || p < bestP) {
              bestP = p;
            }
          }
        }
        raw = bestP;
      }
      
      if (typeof raw === "number") return raw;
      if (raw == null) return null;
      const p = parseFloat(String(raw));
      return Number.isFinite(p) ? p : null;
    },
  
    extractORBeta(v){
      // First check direct or_beta (legacy format)
      let cand = v?.or_beta ?? v?.OR ?? v?.or ?? v?.beta ?? null;
      
      // If not found, check the new nested format for risk_score
      if (cand == null && v?.associated_disease_trait && typeof v.associated_disease_trait === "object") {
        // Get the best (highest) risk_score from all disease traits
        let bestRisk = null;
        for (const traitData of Object.values(v.associated_disease_trait)) {
          if (traitData?.risk_score != null) {
            const risk = traitData.risk_score;
            if (bestRisk == null || risk > bestRisk) {
              bestRisk = risk;
            }
          }
        }
        cand = bestRisk;
      }
      
      return (typeof cand === "number") ? cand : null;
    },
  
    normalizeGeneData(obj){
      // 1) merge all annotations everywhere
      let ann = this.collectVariantAnnotations(obj);
      
      // If obj is already a variant dictionary (from dbsnp_variants), use it directly
      if (obj && typeof obj === "object" && !obj.variant_annotations && !obj.summary_by_high_risk_alleles && !obj.total_associations) {
        // This looks like it's already a variant dictionary (rsid -> variant_data)
        ann = obj;
      }
  
      // 2) possible fallback IDs
      const fallbackIDs = this.deepCollectStringArray(obj, ["high_risk_snps","gwas_high_risk_snps","snps"]);
  
      // 3) build variants
      const byId = {};
      const variants = Object.entries(ann).map(([vid, v])=>{
        const row = {
          id: vid,
          p_value: this.extractP(v),
          context: this.extractContext(v),
          or_beta: this.extractORBeta(v),
          traits: this.extractVariantTraits(v),
        };
        byId[vid] = row;
        return row;
      });
  
      // 4) add fallback-only ids if needed
      for (const vid of fallbackIDs){
        if (vid && !byId[vid]) {
          byId[vid] = { id: vid, p_value: null, context: "", or_beta: null, traits: [] };
          variants.push(byId[vid]);
        }
      }
  
      // 5) trait universe: start with traits that actually map to variants
      const traitSet = new Set();
      variants.forEach(v => (v.traits||[]).forEach(t => t && traitSet.add(t)));
  
      // Optionally include other summary trait lists (will appear even if unmapped)
      const extraTraits = this.deepCollectStringArray(obj, [
        "disease_traits","gwas_disease_traits","traits","mapped_traits","phenotypes"
      ]);
      for (const t of extraTraits) traitSet.add(t);
  
      const traits = Array.from(traitSet).sort((a,b)=>a.localeCompare(b));
  
      // 6) maps
      const mapT2V = {};
      const mapV2T = {};
      for (const v of variants){
        const tlist = (v.traits||[]);
        mapV2T[v.id] = tlist.slice().sort((a,b)=>a.localeCompare(b));
        for (const t of tlist) {
          if (!t) continue;
          (mapT2V[t] ||= []).push(v.id);
        }
      }
      for (const t in mapT2V){
        mapT2V[t].sort((a,b)=>{
          const va = byId[a], vb = byId[b];
          const pa = (va?.p_value ?? Number.POSITIVE_INFINITY);
          const pb = (vb?.p_value ?? Number.POSITIVE_INFINITY);
          return pa - pb;
        });
      }
  
      return { traits, variants, mapT2V, mapV2T };
    },
  
    ensureStateForGene(safeId, obj, rawKey){
      if (!this.state[safeId]){
        const data = this.normalizeGeneData(obj);
        this.state[safeId] = {
          rawKey,
          mode: "traits",
          selectedTrait: data.traits.find(t => (data.mapT2V[t]||[]).length) || data.traits[0] || null,
          selectedVariant: data.variants
            .slice()
            .sort((a,b)=>(a.p_value??1e300)-(b.p_value??1e300))[0]?.id || null,
          data
        };
      }
      return this.state[safeId];
    },
  
    setMode(id, mode){ const s=this.state[id]; if(!s) return; s.mode=mode; this.renderGene(id); },
    selectTrait(id, trait){ const s=this.state[id]; if(!s) return; s.selectedTrait=trait; s.mode="traits"; this.renderGene(id); },
    selectVariant(id, varId){ const s=this.state[id]; if(!s) return; s.selectedVariant=varId; s.mode="variants"; this.renderGene(id); },
  
    fmtP(p){
      if (p == null || !isFinite(p)) return "NA";
      if (p === 0) return "<1e-300";
      return (p < 1e-3) ? p.toExponential(2) : p.toFixed(3);
    },
  
    geneCounts(obj, data){
      const nVars = data.variants.length;
      const nTraits = data.traits.length;
      const total   = obj?.total_associations ?? nVars;
      const signif  = obj?.total_significant_associations ?? null;
      const studies = obj?.total_studies_analyzed ?? null;
      const bits = [
        `${nTraits} trait${nTraits===1?"":"s"}`,
        `${nVars} variant${nVars===1?"":"s"}`
      ];
      if (Number.isFinite(total))   bits.push(`total: ${total}`);
      if (Number.isFinite(signif))  bits.push(`significant: ${signif}`);
      if (Number.isFinite(studies)) bits.push(`studies: ${studies}`);
      return bits.join(" • ");
    },
  
    renderGene(id){
      const mount = document.getElementById(`gwas-${id}`);
      const s = this.state[id];
      if (!mount || !s) return;
  
      const displayGene = s.rawKey;
      const { data, mode } = s;
  
      const tabs = `
        <div class="gwas-tabs">
          <button class="${mode==='traits'?'active':''}" onclick="GWAS.setMode('${id}','traits')">Traits</button>
          <button class="${mode==='variants'?'active':''}" onclick="GWAS.setMode('${id}','variants')">Variants</button>
        </div>`;
  
      // Left column
      let listHTML = "";
      if (mode === "traits"){
        const pills = data.traits.map(t => {
          const js = String(t).replace(/\\/g,"\\\\").replace(/'/g,"\\'");
          const cls = (s.selectedTrait===t) ? "pill clickable selected" : "pill clickable";
          return `<span class="${cls}" onclick="GWAS.selectTrait('${id}','${js}')">${escapeHtml(t)}</span>`;
        }).join("");
        listHTML = `<div class="gwas-list">${pills || '<div class="muted">No traits found.</div>'}</div>`;
      } else {
        const rows = data.variants
          .slice()
          .sort((a,b)=> (a.p_value??1e300)-(b.p_value??1e300))
          .map(v => `
            <tr class="clickable" onclick="GWAS.selectVariant('${id}','${v.id}')">
              <td class="mono">${escapeHtml(v.id)}</td>
              <td>${escapeHtml(v.context||"")}</td>
              <td class="mono">${this.fmtP(v.p_value)}</td>
              <td class="gwas-meta">${(v.traits||[]).length}</td>
            </tr>`).join("");
        listHTML = rows
          ? `<div class="gwas-list">
               <table class="gwas-table">
                 <thead><tr><th>Variant</th><th>Context</th><th>P</th><th>#traits</th></tr></thead>
                 <tbody>${rows}</tbody>
               </table>
             </div>`
          : '<div class="muted">No variants found.</div>';
      }
  
      // Right column
      let detailHTML = "";
      if (mode === "traits"){
        const t = s.selectedTrait;
        if (!t){
          detailHTML = '<div class="muted">Select a trait to see associated variants.</div>';
        } else {
          const vIds = s.data.mapT2V[t] || [];
          if (!vIds.length){
            detailHTML = `<div><strong>${escapeHtml(t)}</strong><div class="muted">No variants mapped to this trait.</div></div>`;
          } else {
            const rows = vIds.map(vid => {
              const v = s.data.variants.find(x=>x.id===vid);
              return `<tr>
                <td class="mono">${escapeHtml(vid)}</td>
                <td>${escapeHtml(v?.context||"")}</td>
                <td class="mono">${this.fmtP(v?.p_value)}</td>
              </tr>`;
            }).join("");
            detailHTML = `
              <div><strong>${escapeHtml(t)}</strong></div>
              <div class="muted" style="margin:4px 0 8px;">${vIds.length} variant${vIds.length===1?'':'s'}</div>
              <div class="gwas-detail">
                <table class="gwas-table">
                  <thead><tr><th>Variant</th><th>Context</th><th>P</th></tr></thead>
                  <tbody>${rows}</tbody>
                </table>
              </div>`;
          }
        }
      } else {
        const varId = s.selectedVariant;
        if (!varId){
          detailHTML = '<div class="muted">Select a variant to see associated traits.</div>';
        } else {
          const v = s.data.variants.find(x=>x.id===varId);
          const traits = s.data.mapV2T[varId] || [];
          const traitPills = traits.map(t => `<span class="pill">${escapeHtml(t)}</span>`).join("");
          detailHTML = `
            <div><strong>${escapeHtml(varId)}</strong></div>
            <div class="gwas-meta">context: ${escapeHtml(v?.context||"")} • p: <span class="mono">${this.fmtP(v?.p_value)}</span>${(v?.or_beta!=null?` • OR/Beta: ${v.or_beta}`:"")}</div>
            <div class="gwas-detail" style="margin-top:8px;">
              <div class="muted" style="margin-bottom:6px;">Traits</div>
              ${traitPills || '<div class="muted">No traits available.</div>'}
            </div>`;
        }
      }
  
      const counts = this.geneCounts(window.__GWAS_RAW?.[s.rawKey] || {}, s.data);
      mount.innerHTML = `
        <div class="gwas-head">
          <div>
            <div><strong>${escapeHtml(uc(displayGene))}</strong></div>
            <div class="gwas-meta">${counts}</div>
          </div>
          ${tabs}
        </div>
        <div class="gwas-grid" style="margin-top:8px;">
          <div>${listHTML}</div>
          <div>${detailHTML}</div>
        </div>`;
    }
  };
  
  function renderGWAS(st){
    const gw = st?.gwas_associations;
    const dbsnp = st?.dbsnp_variants;
    if (!gw || typeof gw !== 'object') return hide("gwasCard");
    window.__GWAS_RAW = gw;
  
    const html = Object.keys(gw).map(gene => {
      const safe = gene.replace(/[^a-z0-9_-]/gi, '_');
      return `<div id="gwas-${safe}" style="margin-bottom:16px;"></div>`;
    }).join("");
    if (!html.trim()){ hide("gwasCard"); return; }
  
    setHTML("gwas", html);
    show("gwasCard");
  
    for (const [rawGene, obj] of Object.entries(gw)){
      const safe = rawGene.replace(/[^a-z0-9_-]/gi, '_');
      // Use dbsnp_variants data if available, otherwise fall back to gwas_associations
      const variantData = dbsnp?.[rawGene] || obj;
      GWAS.ensureStateForGene(safe, variantData, rawGene);
      GWAS.renderGene(safe);
    }
  }
  

  function renderGENCODE(st){
    const gc = st?.gene_level_gencode;
    if (!gc || typeof gc !== 'object') return hide("gencodeCard");

    const W = 700, H = 150;
    const P = { top: 10, right: 10, bottom: 40, left: 28 };

    const sections = Object.entries(gc).map(([gene, obj])=>{
      if (!obj || typeof obj !== 'object') return "";

      const exonsMap = obj.exons_per_transcript || {};
      const counts = Object.values(exonsMap).map(v=>Number(v)).filter(n=>Number.isFinite(n));
      const nTx = Array.isArray(obj.transcript_ids) ? obj.transcript_ids.length : (obj.n_transcripts ?? counts.length);

      const spanMin = obj.min_transcript_span_bp, spanMax = obj.max_transcript_span_bp;
      const spanLine = (spanMin && spanMax) ? `<div class="muted">span: ${escapeHtml(spanMin)}–${escapeHtml(spanMax)} bp</div>` : "";

      if (!counts.length){
        return `<div style="margin-bottom:14px;">
          <div><strong>${escapeHtml(uc(gene))}</strong></div>
          <div class="muted">transcripts: ${nTx}</div>
          ${spanLine}
          <div class="muted">No exon data available to plot.</div>
        </div>`;
      }

      const freq = {};
      for (const n of counts) freq[n] = (freq[n]||0) + 1;
      const bins = Object.keys(freq).map(Number).sort((a,b)=>a-b);
      const maxCount = Math.max(...bins.map(b => freq[b]));

      const sorted = [...counts].sort((a,b)=>a-b);
      const mid = Math.floor(sorted.length/2);
      const median = (sorted.length % 2) ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;

      const plotW = W - P.left - P.right;
      const plotH = H - P.top - P.bottom;
      const bandW = plotW / bins.length;
      const gap = Math.min(6, Math.max(2, bandW * 0.12));

      const bars = bins.map((b, i) => {
        const c = freq[b];
        const h = (c / maxCount) * plotH;
        const x = P.left + i * bandW + gap/2;
        const y = P.top + (plotH - h);
        const w = Math.max(1, bandW - gap);
        return `<rect class="hist-bar" x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${w.toFixed(2)}" height="${Math.max(0,h).toFixed(2)}">
                  <title>${b} exons • ${c} transcript${c===1?"":"s"}</title>
                </rect>`;
      }).join("");

      const tickY = H - 18;
      let xLabels = "";
      if (bins.length <= 18) {
        xLabels = bins.map((b, i) => {
          const x = P.left + i * bandW + bandW/2;
          return `<text class="hist-axis" x="${x.toFixed(2)}" y="${tickY}" text-anchor="middle">${b}</text>`;
        }).join("");
      } else {
        const minB = bins[0], maxB = bins[bins.length-1];
        const nearestIdx = Math.max(0, Math.min(bins.length-1, bins.findIndex(v => v>=median)));
        const xMin = P.left + 0 * bandW + bandW/2;
        const xMed = P.left + nearestIdx * bandW + bandW/2;
        const xMax = P.left + (bins.length-1) * bandW + bandW/2;
        xLabels = `
          <text class="hist-axis" x="${xMin.toFixed(2)}" y="${tickY}" text-anchor="middle">${minB}</text>
          <text class="hist-axis" x="${xMed.toFixed(2)}" y="${tickY}" text-anchor="middle">median ${median}</text>
          <text class="hist-axis" x="${xMax.toFixed(2)}" y="${tickY}" text-anchor="middle">${maxB}</text>
        `;
      }

      const baseY = P.top + plotH;
      const baseline = `<line class="hist-baseline" x1="${P.left}" y1="${baseY}" x2="${W-P.right}" y2="${baseY}"/>`;
      const xTitle = `<text class="hist-axis" x="${W/2}" y="${H-4}" text-anchor="middle"># exons</text>`;
      const yTitle = `<text class="hist-axis" transform="rotate(-90 12 ${H/2})" x="12" y="${H/2}" text-anchor="middle"># transcripts</text>`;

      return `<div style="margin-bottom:16px;">
        <div><strong>${escapeHtml(uc(gene))}</strong></div>
        <div class="muted">transcripts: ${nTx} • median exons: ${median}</div>
        ${spanLine}
        <svg class="hist-svg" viewBox="0 0 ${W} ${H}">
          ${yTitle}
          ${baseline}
          ${bars}
          ${xLabels}
          ${xTitle}
        </svg>
      </div>`;
    }).join("");

    if (sections.trim()) { setHTML("gencode", sections); show("gencodeCard"); }
    else hide("gencodeCard");
  }
  // ---------------- Variant Summary renderer (SEI / Expecto / AM columns shown only when available) ----------------
  window.__EXPECTO_DETAILS  = window.__EXPECTO_DETAILS  || {}; // geneKey -> { rsSafe -> detailHTML }
  window.__EXPECTO_EXPANDED = window.__EXPECTO_EXPANDED || {}; // geneKey -> Set(rsSafe)
  function renderVariantSummary(st){
  const sei    = st?.sei_predictions || {};
  const am     = st?.alphamissense_predictions || {};
  const dbsum  = st?.dbsnp_summaries || {};
  const gwas   = st?.gwas_associations || {};
  const dbsnp  = st?.dbsnp_variants || {};
  const exVar  = st?.expression_preds_variant_table || {}; // gene -> rsid -> metrics

  // ---- helpers ----
  const freqLabel = (rs, geneDb) => {
    const rareSet       = new Set(geneDb?.["rare_rsids"] || []);
    const commonSet     = new Set(geneDb?.["common_rsids"] || []);
    const veryCommonSet = new Set(geneDb?.["very_common_rsids"] || []);
    return (
      rareSet.has(rs)       ? "Rare (<1%)" :
      commonSet.has(rs)     ? "Common (1–15%)" :
      veryCommonSet.has(rs) ? "Very common (over 15%)" : "N/A"
    );
  };
  const fmtNum = (x, digits=3) => {
    const n = (typeof x === "number") ? x : parseFloat(String(x));
    if (!Number.isFinite(n)) return "NA";
    return Math.abs(n) < 1e-3 ? n.toExponential(2) : n.toFixed(digits);
  };
  const asPctInt = (p) => {
    if (p == null) return null;
    let n = (typeof p === "number") ? p : parseFloat(String(p));
    if (!Number.isFinite(n)) return null;
    if (n <= 1) n *= 100; // accept [0,1]
    n = Math.round(n);
    return Math.max(0, Math.min(100, n));
  };
  const ordinal = (n) => {
    if (n == null) return "NA";
    const v = Math.abs(n);
    const j = v % 10, k = v % 100;
    if (j === 1 && k !== 11) return v + "st";
    if (j === 2 && k !== 12) return v + "nd";
    if (j === 3 && k !== 13) return v + "rd";
    return v + "th";
  };
  const sanitizeId = (s) => String(s || "").replace(/[^a-z0-9_-]/gi, "_");

  // robust collectors (use GWAS helpers if present; otherwise deep-scan)
  const collectVariantAnnotations = (obj) => {
    if (window.GWAS?.collectVariantAnnotations) return GWAS.collectVariantAnnotations(obj);
    const out = {}; const seen = new Set();
    (function walk(x){
      if (!x || typeof x !== "object" || seen.has(x)) return;
      seen.add(x);
      if (x.variant_annotations && typeof x.variant_annotations === "object" && !Array.isArray(x.variant_annotations)){
        Object.assign(out, x.variant_annotations);
      }
      if (x.dbsnp_variants && typeof x.dbsnp_variants === "object" && !Array.isArray(x.dbsnp_variants)){
        Object.assign(out, x.dbsnp_variants);
      }
      for (const v of Object.values(x)) walk(v);
    })(obj || {});
    return out;
  };
  const extractTraits = (v) => {
    if (window.GWAS?.extractVariantTraits) return GWAS.extractVariantTraits(v);
    const out = new Set();
    const add = s => { if (s && typeof s === "string") out.add(s); };
    const addMany = a => { if (Array.isArray(a)) a.forEach(add); };
    if (!v) return [];
    
    // Handle new nested format: associated_disease_trait: { trait_name: { p_value, risk_score } }
    if (v?.associated_disease_trait && typeof v.associated_disease_trait === "object") {
      Object.keys(v.associated_disease_trait).forEach(add);
    }
    
    // Handle legacy formats for compatibility
    addMany(v?.disease_trait); add(v?.disease_trait);
    addMany(v?.traits); add(v?.trait);
    addMany(v?.phenotypes); add(v?.phenotype);
    addMany(v?.mapped_traits); add(v?.mapped_trait);
    addMany(v?.gwas_disease_traits);
    return Array.from(out);
  };
  const extractP = (v) => {
    if (window.GWAS?.extractP) return GWAS.extractP(v);
    // First check direct p_value (legacy format)
    let raw = (v?.p_value ?? v?.p ?? null);
    
    // If not found, check the new nested format: associated_disease_trait: { trait_name: { p_value, risk_score } }
    if (raw == null && v?.associated_disease_trait && typeof v.associated_disease_trait === "object") {
      // Get the best (lowest) p_value from all disease traits
      let bestP = null;
      for (const traitData of Object.values(v.associated_disease_trait)) {
        if (traitData?.p_value != null) {
          const p = traitData.p_value;
          if (bestP == null || p < bestP) {
            bestP = p;
          }
        }
      }
      raw = bestP;
    }
    
    if (typeof raw === "number") return raw;
    if (raw == null) return null;
    const n = parseFloat(String(raw));
    return Number.isFinite(n) ? n : null;
  };
  const extractContext = (v) => {
    if (window.GWAS?.extractContext) return GWAS.extractContext(v);
    return v?.context || v?.variant_category || v?.functional_annotation || v?.consequence || "";
  };
  const extractCategory = (v) => (v?.variant_category ?? v?.functional_annotation ?? v?.consequence ?? "");
  const extractMappedGene = (v) => {
    if (typeof v?.mapped_gene === "string") return v.mapped_gene;
    if (Array.isArray(v?.mapped_genes) && v.mapped_genes.length) return v.mapped_genes[0];
    return v?.mapped_gene_name || v?.gene || "";
  };

  // Which genes appear anywhere
  const genes = new Set([
    ...Object.keys(gwas || {}),
    ...Object.keys(dbsum || {}),
    ...Object.keys(sei || {}),
    ...Object.keys(am || {}),
    ...Object.keys(exVar || {})
  ]);

  // detail store (for Expecto "Details")
  
  const sections = [];

  for (const gene of genes){
    const geneSei = sei[gene] || {};
    const geneAm  = am[gene]  || {};
    const geneDb  = dbsum[gene] || {};
    const gwasObj = gwas[gene] || {};
    const dbsnpObj = dbsnp[gene] || {};
    const combinedDataForGene = { gwas: gwasObj, dbsnp: dbsnpObj };
    const geneEx  = exVar[gene] || {}; // rsid -> metrics

    // Prefer per-gene annotations, but if empty due to nesting, fall back to global scan
    const gwasAnnotations = collectVariantAnnotations(gwas[gene] || {});

    // Get variants directly from dbSNP (which does not use the nested key)
    const dbsnpAnnotations = dbsnp[gene] || {};

    // Merge them together. Data from dbSNP will overwrite GWAS data for any overlapping variants.
    let ann = { ...gwasAnnotations, ...dbsnpAnnotations };

    // Fallback logic to scan all genes if the current gene yielded nothing
    if (Object.keys(ann).length === 0) {
      const globalGwasAnn = collectVariantAnnotations(gwas);
      // For dbSNP, we need to merge the variant objects from all genes
      const globalDbsnpAnn = Object.values(dbsnp || {}).reduce((acc, geneData) => ({...acc, ...geneData}), {});
      ann = { ...globalGwasAnn, ...globalDbsnpAnn };
    }

    // rsids for this gene
    const rsids = new Set([
      ...Object.keys(ann || {}),
      ...Object.keys(geneSei || {}),
      ...Object.keys(geneAm || {}),
      ...Object.keys(geneEx || {}),
      ...(geneDb?.["rare_rsids"] || []),
      ...(geneDb?.["common_rsids"] || []),
      ...(geneDb?.["very_common_rsids"] || [])
    ]);
    if (rsids.size === 0) continue;

    // Build rows
    const rows = Array.from(rsids).map(rs => {
      const vAnn     = ann?.[rs] || {};
      const seiLabel = (rs in geneSei) ? (geneSei[rs] ?? "N/A") : "N/A";

      // AlphaMissense
      const amMap = geneAm?.[rs] || null;
      let amList = [];
      if (amMap && typeof amMap === "object"){
        for (const [change, label] of Object.entries(amMap)){
          const c = String(change || "").replace(/^SNP:/i, "").replace("->", "→");
          amList.push(label ? `${c}: ${label}` : c);
        }
      }
      if (amList.length === 0) amList = ["N/A"];

      // Expecto per-variant metrics (if present)
            // Expecto per-variant metrics (if present)
            const ex = geneEx?.[rs] || null;
            let expectoSummaryHtml = "N/A";
            let expectoDetailHtml = "";
            if (ex && typeof ex === "object"){
              // Helpers
              const pctInt   = asPctInt(ex.percentile); // may not exist globally; we'll use per-tissue percentiles below
              const mean     = fmtNum(ex.mean_score);
              const median   = fmtNum(ex.median_score);
              const min_s    = fmtNum(ex.min_score);
              const max_s    = fmtNum(ex.max_score);
              const std_s    = fmtNum(ex.std_score);
              const n_t      = (ex.n_tissues ?? "NA");
              const coord    = ex.variant ? `${escapeHtml(ex.variant.chr || "")}:${escapeHtml(String(ex.variant.position || ""))} ${escapeHtml(ex.variant.alt || "")}` : "";
      
              const top1 = Array.isArray(ex.top_tissues) && ex.top_tissues.length ? ex.top_tissues[0] : null;
              const bot1 = Array.isArray(ex.bottom_tissues) && ex.bottom_tissues.length ? ex.bottom_tissues[0] : null;
      
              const tissueLabel = (t) => {
                if (!t) return "";
                const bits = [t.tissue, t.organ, t.system, t.category].filter(Boolean);
                return escapeHtml(bits.join(" / ") || String(t.tissue || ""));
              };
              const pctLabel = (p) => {
                const pI = asPctInt(p);
                return pI == null ? "NA" : `${ordinal(pI)} pct`;
              };
      
              const lineHTML = (tag, t) => {
                if (!t) return "";
                // score highlighted, percentile mono, tissue bold
                return `<span class="expecto-line">${tag} <span class="xnum">${fmtNum(t.score)}</span> (<span class="xpct">${pctLabel(t.percentile_in_tissue)}</span>) — <span class="xtissue">${tissueLabel(t)}</span></span>`;
              };
      
              // ** headline-style summary (no mean/median here) **
              const topLine = lineHTML("highest", top1);
              const botLine = lineHTML("lowest",  bot1);
              const lines   = [topLine, botLine].filter(Boolean);
              expectoSummaryHtml = lines.length ? lines.join("") : "N/A";
      
              // ** full stats + lists are in the Details panel **
              const listify = (arr) => {
                if (!Array.isArray(arr) || !arr.length) return '<div class="muted">None</div>';
                return `<ul style="margin:6px 0 0 16px; padding:0;">
                  ${arr.map(t=>{
                    const lbl = tissueLabel(t);
                    return `<li><span class="xtissue">${lbl}</span> — score <span class="mono">${fmtNum(t.score)}</span>, ${pctLabel(t.percentile_in_tissue)}</li>`;
                  }).join("")}
                </ul>`;
              };
      
              expectoDetailHtml = `
                <div class="muted">ExpectoSC (cell-type specific expression disruption)</div>
                ${coord ? `<div class="mono" style="margin:2px 0 6px;">${coord}</div>` : ""}
                <div>n_tissues: ${escapeHtml(String(n_t))} • mean: ${mean} • median: ${median} • min: ${min_s} • max: ${max_s} • std: ${std_s}</div>
                ${ex.relative_effect ? `<div style="margin-top:4px;">relative effect: ${escapeHtml(String(ex.relative_effect))}</div>` : ""}
                ${topLine || botLine ? `<div style="margin-top:6px;">${topLine || ""}${botLine || ""}</div>` : ""}
                <div style="margin-top:6px;"><strong>Top tissues</strong>${listify(ex.top_tissues)}</div>
                <div style="margin-top:6px;"><strong>Lowest tissues</strong>${listify(ex.bottom_tissues)}</div>
              `;
            }
      

            return {
              rs,
              freq: freqLabel(rs, geneDb),
              context: extractContext(vAnn),
              category: extractCategory(vAnn),
              mapped_gene: extractMappedGene(vAnn),
              sei: seiLabel || "N/A",
              expectoHtml: expectoSummaryHtml || "N/A",   
              expectoDetailHtml,
              am: amList,
              traits: extractTraits(vAnn),
              p: extractP(vAnn)
            };
    });

    // Sort rows by frequency bucket, p-value asc, then rsid
    const freqOrder = {"Rare (<1%)":0, "Common (1–15%)":1, "Very common (>15%)":2, "N/A":3};
    rows.sort((a,b)=>{
      const fa = (freqOrder[a.freq] ?? 9), fb = (freqOrder[b.freq] ?? 9);
      if (fa !== fb) return fa - fb;
      const pa = (a.p ?? Number.POSITIVE_INFINITY), pb = (b.p ?? Number.POSITIVE_INFINITY);
      if (pa !== pb) return pa - pb;
      return a.rs.localeCompare(b.rs);
    });

    // Column visibility (per gene)
    const hasSeiCol     = rows.some(r => r.sei && r.sei !== "N/A");
const hasAmCol      = rows.some(r => Array.isArray(r.am) && r.am.some(x => x && x !== "N/A"));
const hasExpectoCol = rows.some(r => r.expectoHtml && r.expectoHtml !== "N/A"); // was r.expecto

const headerCols = `
  <th>Variant</th>
  <th>Frequency</th>
  <th>Context</th>
  <th>Category</th>
  <th>Mapped gene</th>
  ${hasSeiCol ? '<th>SEI</th>' : ''}
  ${hasExpectoCol ? '<th class="wrap">ExpectoSC</th>' : ''}
  ${hasAmCol ? '<th>AlphaMissense</th>' : ''}
  <th class="wrap">GWAS traits</th>
`;

    // Prepare detail store for this gene
    const gkey = sanitizeId(gene);
    window.__EXPECTO_DETAILS[gkey] = window.__EXPECTO_DETAILS[gkey] || {};

    // Compute colspan for detail rows
    const baseCols = 5 /* fixed cols */ + 1 /* GWAS traits */;
    const colspan = baseCols + (hasSeiCol?1:0) + (hasExpectoCol?1:0) + (hasAmCol?1:0);

    // Rows HTML (Expecto cell is .wrap, Traits cell is .traits.wrap)
    const rowsHtml = rows.map(r=>{
      const amHtml = (Array.isArray(r.am) ? r.am : ["N/A"])
        .map(x => `<span class="pill">${escapeHtml(String(x))}</span>`).join(" ");
      const tShown = (r.traits || []).slice(0, 8);
      const traitsHtml = tShown.map(t => `<span class="pill">${escapeHtml(String(t))}</span>`).join(" ")
        + ((r.traits && r.traits.length > 8) ? `<span class="muted"> +${r.traits.length - 8} more</span>` : "");

      const rsSafe = sanitizeId(r.rs);
      const hasDetail = Boolean(r.expectoDetailHtml && r.expectoDetailHtml.trim());
      if (hasDetail) window.__EXPECTO_DETAILS[gkey][rsSafe] = r.expectoDetailHtml;

      const expectoCell = hasExpectoCol
        ? `<td class="expecto wrap">${r.expectoHtml || 'N/A'}${hasDetail ? ` <button class="mini" onclick="toggleExpectoDetails('${gkey}','${rsSafe}', ${colspan})">Details</button>` : ""}</td>`
        : "";

      const mainRow = `<tr>
        <td class="mono">${escapeHtml(r.rs)}</td>
        <td>${escapeHtml(r.freq)}</td>
        <td>${escapeHtml(r.context || "N/A")}</td>
        <td>${escapeHtml(r.category || "N/A")}</td>
        <td>${escapeHtml(r.mapped_gene || "N/A")}</td>
        ${hasSeiCol ? `<td>${escapeHtml(r.sei)}</td>` : ""}
        ${expectoCell}
        ${hasAmCol ? `<td>${amHtml || 'N/A'}</td>` : ""}
        <td class="traits wrap">${traitsHtml || '<span class="muted">N/A</span>'}</td>
      </tr>`;

      const expandedSet = (window.__EXPECTO_EXPANDED[gkey] ||= new Set());
      const isOpen = expandedSet.has(rsSafe);

      const detailRow = (hasDetail && hasExpectoCol)
        ? `<tr id="expd_${gkey}_${rsSafe}" class="exp-detail" style="${isOpen ? "" : "display:none;"}">
             <td colspan="${colspan}">
               <div class="exp-detail-box">${window.__EXPECTO_DETAILS[gkey][rsSafe]}</div>
             </td>
           </tr>`
        : "";

      return mainRow + detailRow;
    }).join("");

    // Optional top-line counts from dbsnp_summaries
    const statsBits = [];
    if (Number.isFinite(geneDb?.["num_rare_variants (<1%)"]))         statsBits.push(`rare: ${geneDb["num_rare_variants (<1%)"]}`);
    if (Number.isFinite(geneDb?.["num_common_variants (1-15%)"]))     statsBits.push(`common: ${geneDb["num_common_variants (1-15%)"]}`);
    if (Number.isFinite(geneDb?.["num_very_common_variants (>15%)"])) statsBits.push(`very common: ${geneDb["num_very_common_variants (>15%)"]}`);

    sections.push(`
      <div style="margin-bottom:8px;">
        <strong>${escapeHtml(uc(gene))}</strong>
        ${statsBits.length ? `<span class="muted"> • ${statsBits.join(" • ")}</span>` : ""}
      </div>
      <div class="vs-scroll">
        <table class="vs-table">
          <thead><tr>${headerCols}</tr></thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      </div>
    `);
  }

  if (sections.length){
    setHTML("variantSummary", sections.join(""));
    show("variantSummaryCard");
  } else {
    hide("variantSummaryCard");
  }
}

// Tiny helper 
function toggleExpectoDetails(geneKey, rsSafe, colspan){
  const rowId = `expd_${geneKey}_${rsSafe}`;
  const row = document.getElementById(rowId);
  if (!row) return;

  const store = (window.__EXPECTO_EXPANDED[geneKey] ||= new Set());
  const opening = (row.style.display === "none" || !row.style.display);

  row.style.display = opening ? "" : "none";
  if (opening) { store.add(rsSafe); row.scrollIntoView({block:"nearest", behavior:"smooth"}); }
  else { store.delete(rsSafe); }
}

  function renderDebug(st){
    const keys = [
      "uniprot_entries_gwas",
      "gene_disease_traits",
      "gene_function_traits",
      "gene_GO_traits",
      "humanbase_predictions",
      "humanbase_expecto",
      "tissue_expression_preds_variant_text_description",
      "dbsnp_variants",
      "dbsnp_summaries",
      "sei_predictions",
      "alphamissense_predictions",
      "biogrid_summarized_go"
    ];
    const subset = {};
    for (const k of keys) {
      const v = st?.[k];
      if (v && ((Array.isArray(v) && v.length) || (typeof v === 'object' && Object.keys(v).length))) {
        subset[k] = v;
      }
    }
    if (Object.keys(subset).length) { setText("debug", JSON.stringify(subset, null, 2)); show("debugCard"); } else hide("debugCard");
  }

  function renderRaw(st){
    if (st) { setText("raw", JSON.stringify(st, null, 2)); show("rawCard"); }
    else hide("rawCard");
  }

  // Orchestration
  async function refresh(qJustRan="") {
    const st = await fetchState();
    if (!st) return;
  
    const hero = document.getElementById('hero');
    if (hero && hero.style.display !== 'none'){ hide('hero'); show('grid'); }
    show('toolbar');
    const q2 = document.getElementById('q2'); if (q2) { q2.value = ""; q2.focus(); }
  
    renderQuestion(st, qJustRan);
    renderEntities(st);
    renderTools(st);
    renderAnswer(st);
    renderBioGRID(st);
    renderReactome(st);
    renderUniProtBase(st);
    renderGWAS(st);
    renderVariantSummary(st);
  
    renderGENCODE(st);
    renderDebug(st);
    renderRaw(st);
  }
  // Run helpers
  async function run(qOverride) {
    const qEl = document.getElementById("q");
    const q = (typeof qOverride === "string" ? qOverride : (qEl?.value || "")).trim();
    if (!q) { alert("Type a question first."); return; }
    if (qEl) qEl.blur();

    // Clear previous sections; keep layout
    hideAllSections();
    setStatus("(waiting for output…)");
    showRunStatus();

    // Start polling logs before kicking off the run
    startLogPolling();

    const res = await fetch("/run?q=" + encodeURIComponent(q));
    if (!res.ok) {
      setStatus("Run failed.");
      setTimeout(()=>{ stopLogPolling(); hideRunStatus(); }, 800);
      return;
    }

    await refresh(q);
    setTimeout(()=>{ stopLogPolling(); hideRunStatus(); }, 800);
  }

  function runFrom(inputId){
    const el = document.getElementById(inputId);
    const val = el ? el.value.trim() : "";
    if (!val) { alert("Type a question first."); return; }
    run(val);
  }

  // Enter-to-run
  window.addEventListener('load', () => {
    const input = document.getElementById('q');
    input?.focus();
    input?.addEventListener('keydown', (e) => { if (e.key === 'Enter') run(); });

    const input2 = document.getElementById('q2');
    input2?.addEventListener('keydown', (e) => { if (e.key === 'Enter') runFrom('q2'); });
  });
</script>
</body>
</html>

